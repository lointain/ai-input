{
  "name": "ai-input",
  "type": "registry:component",
  "title": "AI Input",
  "description": "A Notion-style AI input with drag & drop, slash commands, and mentions.",
  "dependencies": [
    "@tiptap/vue-3",
    "@tiptap/starter-kit",
    "@tiptap/extension-placeholder",
    "@tiptap/extension-mention",
    "lucide-vue-next",
    "tippy.js"
  ],
  "registryDependencies": [
    "button",
    "badge",
    "card",
    "separator"
  ],
  "files": [
    {
      "path": "ui/ai-input/components\\AIInput.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * AIInput.vue\r\n * \r\n * Main container component for the AI Input system.\r\n * Handles file drag-and-drop, file input management, and provides context to child components.\r\n * \r\n * @component\r\n * @example\r\n * <AIInput \r\n *   :upload-handler=\"myUploadHandler\"\r\n *   placeholder=\"Type something...\"\r\n *   @submit=\"handleSubmit\"\r\n * >\r\n *   <AIInputEditor />\r\n *   <AIInputToolbar />\r\n * </AIInput>\r\n * \r\n * @slot default - The content to be rendered inside the input container (usually Editor, Toolbar, etc.)\r\n */\r\nimport type { HTMLAttributes } from 'vue'\r\nimport { cn } from '@/lib/utils'\r\nimport { useAIInputProvider, type AIInputProps } from '../core/context'\r\nimport AIInputAttachments from './AIInputAttachments.vue'\r\n\r\n/**\r\n * Props interface for AIInput component\r\n * Extends AIInputProps from context\r\n */\r\ninterface Props extends AIInputProps {\r\n  /** Optional CSS class for the root element */\r\n  class?: HTMLAttributes['class']\r\n}\r\n\r\nconst props = defineProps<Props>()\r\n\r\nconst { addFiles } = useAIInputProvider(props)\r\n\r\n/**\r\n * Handle file selection from the hidden file input\r\n * \r\n * @param {Event} e - The change event from file input\r\n */\r\nfunction onFileChange(e: Event) {\r\n  const input = e.target as HTMLInputElement\r\n  if (input.files) {\r\n    addFiles(input.files)\r\n  }\r\n  input.value = ''\r\n}\r\n\r\n/**\r\n * Handle drag over event to allow dropping files\r\n * Prevents default behavior if dragged items are files\r\n * \r\n * @param {DragEvent} e - The dragover event\r\n */\r\nfunction handleDragOver(e: DragEvent) {\r\n  if (e.dataTransfer?.types?.includes('Files')) {\r\n    e.preventDefault()\r\n  }\r\n}\r\n\r\n/**\r\n * Handle drop event for files\r\n * Adds dropped files to the context\r\n * \r\n * @param {DragEvent} e - The drop event\r\n */\r\nfunction handleDrop(e: DragEvent) {\r\n  if (e.dataTransfer?.types?.includes('Files')) {\r\n    e.preventDefault()\r\n\r\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\r\n      addFiles(e.dataTransfer.files)\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<template>\r\n  <div\r\n    data-ai-input\r\n    :class=\"\r\n      cn(\r\n        'relative flex w-full flex-col overflow-hidden rounded-xl border bg-background focus-within:ring-1 focus-within:ring-ring',\r\n        props.class,\r\n      )\r\n    \"\r\n    @dragover=\"handleDragOver\"\r\n    @drop=\"handleDrop\"\r\n  >\r\n    <input ref=\"fileInputRef\" type=\"file\" class=\"hidden\" multiple @change=\"onFileChange\" />\r\n    <AIInputAttachments />\r\n    <slot />\r\n  </div>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/components\\AIInputAttachButton.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * AIInputAttachButton.vue\r\n * \r\n * A button component that triggers the file input dialog.\r\n * Uses context from AIInput to interact with the hidden file input.\r\n * \r\n * @component\r\n * @example\r\n * <AIInputAttachButton />\r\n */\r\nimport { Button } from '@/components/ui/button'\r\nimport { PaperclipIcon } from 'lucide-vue-next'\r\nimport { useAIInputContext } from '../core/context'\r\n\r\nconst { fileInputRef } = useAIInputContext()\r\n\r\n/**\r\n * Handle click event to trigger file input\r\n * \r\n * @description Triggers a click on the hidden file input element referenced in the context\r\n */\r\nconst onClick = () => {\r\n  fileInputRef.value?.click()\r\n}\r\n</script>\r\n\r\n<template>\r\n  <Button variant=\"ghost\" size=\"icon\" class=\"h-8 w-8 rounded-full\" @click=\"onClick\">\r\n    <PaperclipIcon class=\"h-4 w-4\" />\r\n  </Button>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/components\\AIInputAttachments.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * AIInputAttachments.vue\r\n * \r\n * Displays a list of files currently attached to the input.\r\n * Handles the visualization of upload progress, errors, and provides removal/retry actions.\r\n * \r\n * @component\r\n * @example\r\n * <AIInputAttachments class=\"mb-2\" />\r\n */\r\nimport { cn } from '@/lib/utils'\r\nimport { FileIcon, XIcon, RefreshCwIcon, AlertCircleIcon } from 'lucide-vue-next'\r\nimport { useAIInputContext } from '../core/context'\r\nimport { computed } from 'vue'\r\n\r\nconst props = defineProps<{\r\n  /** Optional CSS class for the container */\r\n  class?: string\r\n}>()\r\n\r\nconst { files, removeFile, retryUpload } = useAIInputContext()\r\n\r\n/**\r\n * Computed property to check if there are any files to display\r\n * @returns {boolean} True if file list is not empty\r\n */\r\nconst hasFiles = computed(() => files.value.length > 0)\r\n</script>\r\n\r\n<template>\r\n  <div\r\n    v-if=\"hasFiles\"\r\n    :class=\"cn('flex flex-wrap items-center gap-2 p-3 w-full border-b bg-muted/30', props.class)\"\r\n  >\r\n    <div\r\n      v-for=\"file in files\"\r\n      :key=\"file.id\"\r\n      class=\"group relative flex items-center gap-2 rounded-lg border bg-background px-3 py-2 text-sm shadow-sm transition-all hover:shadow-md\"\r\n    >\r\n      <!-- Icon based on status -->\r\n      <div class=\"relative flex h-8 w-8 items-center justify-center rounded bg-muted\">\r\n        <AlertCircleIcon v-if=\"file.status === 'error'\" class=\"h-4 w-4 text-destructive\" />\r\n        <FileIcon v-else class=\"h-4 w-4 text-muted-foreground\" />\r\n\r\n        <!-- Progress Overlay -->\r\n        <div\r\n          v-if=\"file.status === 'uploading'\"\r\n          class=\"absolute inset-0 bg-background/50 flex items-center justify-center\"\r\n        >\r\n          <div\r\n            class=\"h-full w-full bg-primary/20 absolute bottom-0 left-0\"\r\n            :style=\"{ height: `${file.progress}%` }\"\r\n          />\r\n        </div>\r\n      </div>\r\n\r\n      <div class=\"flex flex-col max-w-[150px]\">\r\n        <span class=\"truncate font-medium text-xs\">{{ file.name }}</span>\r\n        <span class=\"text-[10px] text-muted-foreground flex items-center gap-1\">\r\n          <template v-if=\"file.status === 'uploading'\"> Uploading {{ file.progress }}% </template>\r\n          <template v-else-if=\"file.status === 'error'\"> Failed </template>\r\n          <template v-else>\r\n            {{ file.file?.size ? (file.file.size / 1024).toFixed(1) + ' KB' : '' }}\r\n          </template>\r\n        </span>\r\n      </div>\r\n\r\n      <!-- Actions -->\r\n      <div class=\"flex items-center gap-1\">\r\n        <button\r\n          v-if=\"file.status === 'error'\"\r\n          type=\"button\"\r\n          class=\"rounded-full p-1 hover:bg-muted text-muted-foreground hover:text-foreground\"\r\n          @click=\"retryUpload(file.id)\"\r\n        >\r\n          <RefreshCwIcon class=\"h-3 w-3\" />\r\n        </button>\r\n\r\n        <button\r\n          type=\"button\"\r\n          class=\"rounded-full p-1 hover:bg-muted text-muted-foreground hover:text-foreground\"\r\n          @click=\"removeFile(file.id)\"\r\n        >\r\n          <XIcon class=\"h-3 w-3\" />\r\n        </button>\r\n      </div>\r\n\r\n      <!-- Progress Bar (Bottom Line) -->\r\n      <div\r\n        v-if=\"file.status === 'uploading'\"\r\n        class=\"absolute bottom-0 left-0 h-0.5 bg-primary transition-all duration-300\"\r\n        :style=\"{ width: `${file.progress}%` }\"\r\n      />\r\n    </div>\r\n  </div>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/components\\AIInputEditor.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * AIInputEditor.vue\r\n * \r\n * Wrapper around Tiptap EditorContent.\r\n * Handles the editor instance injection and editable state synchronization.\r\n * \r\n * @component\r\n * @example\r\n * <AIInputEditor />\r\n */\r\nimport { EditorContent } from '@tiptap/vue-3'\r\nimport { watch } from 'vue'\r\nimport { useAIInputContext } from '../core/context'\r\n\r\nconst { editor, isDisabled } = useAIInputContext()\r\n\r\n/**\r\n * Watch for disabled state changes and update editor editable state\r\n */\r\nwatch(isDisabled, (val) => {\r\n  editor.value?.setEditable(!val)\r\n})\r\n</script>\r\n\r\n<template>\r\n  <div class=\"relative w-full\">\r\n    <EditorContent :editor=\"editor\" />\r\n  </div>\r\n</template>\r\n\r\n<style>\r\n/* Placeholder styles */\r\n.ProseMirror p.is-editor-empty:first-child::before {\r\n  color: hsl(var(--muted-foreground));\r\n  content: attr(data-placeholder);\r\n  float: left;\r\n  height: 0;\r\n  pointer-events: none;\r\n}\r\n</style>\r\n"
    },
    {
      "path": "ui/ai-input/components\\AIInputToolbar.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * AIInputToolbar.vue\r\n * \r\n * The bottom toolbar component containing action buttons and slots for extensions.\r\n * Provides 'left' and 'right' slots for customizing the toolbar layout.\r\n * \r\n * @component\r\n * @example\r\n * <AIInputToolbar>\r\n *   <template #left><AIInputAttachButton /></template>\r\n *   <template #right><AIInputVoice /></template>\r\n * </AIInputToolbar>\r\n * \r\n * @slot left - Slot for left-aligned content (e.g. attachments, formatting)\r\n * @slot right - Slot for right-aligned content (e.g. voice, extra actions)\r\n */\r\nimport { Button } from '@/components/ui/button'\r\nimport { ArrowUpIcon, SquareIcon } from 'lucide-vue-next'\r\nimport { useAIInputContext } from '../core/context'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst { submit, isLoading, isEmpty } = useAIInputContext()\r\n</script>\r\n\r\n<template>\r\n  <div class=\"flex items-center justify-between p-2\">\r\n    <div class=\"flex items-center gap-2\">\r\n      <!-- Left slots (attachments, voice, etc.) -->\r\n      <slot name=\"left\" />\r\n    </div>\r\n\r\n    <div class=\"flex items-center gap-2\">\r\n      <!-- Right slots -->\r\n      <slot name=\"right\" />\r\n\r\n      <Button\r\n        size=\"icon\"\r\n        :variant=\"isLoading ? 'outline' : 'default'\"\r\n        :disabled=\"isEmpty && !isLoading\"\r\n        :class=\"cn('h-8 w-8 rounded-full transition-all', isLoading && 'animate-pulse')\"\r\n        @click=\"submit\"\r\n      >\r\n        <SquareIcon v-if=\"isLoading\" class=\"h-4 w-4 fill-current\" />\r\n        <ArrowUpIcon v-else class=\"h-4 w-4\" />\r\n      </Button>\r\n    </div>\r\n  </div>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/components\\AIInputVoice.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * AIInputVoice.vue\r\n * \r\n * A microphone button that handles speech-to-text input.\r\n * Integrates with the useVoice hook to manage recording state and insertion into the editor.\r\n * \r\n * @component\r\n * @example\r\n * <AIInputVoice />\r\n */\r\nimport { Button } from '@/components/ui/button'\r\nimport { MicIcon } from 'lucide-vue-next'\r\nimport { useVoice } from '../hooks/use-voice'\r\nimport { useAIInputContext } from '../core/context'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst { editor } = useAIInputContext()\r\n\r\n/**\r\n * Initialize voice hook with callback to insert text into editor\r\n * @param {string} text - The transcribed text from speech\r\n */\r\nconst { state, toggle, isSupported } = useVoice((text) => {\r\n  if (editor.value) {\r\n    editor.value\r\n      .chain()\r\n      .focus()\r\n      .insertContent(text + ' ')\r\n      .run()\r\n  }\r\n})\r\n</script>\r\n\r\n<template>\r\n  <Button\r\n    v-if=\"isSupported\"\r\n    size=\"icon\"\r\n    variant=\"ghost\"\r\n    :class=\"\r\n      cn(\r\n        'h-8 w-8 rounded-full transition-all',\r\n        state === 'listening' &&\r\n          'bg-red-100 text-red-600 hover:bg-red-100 hover:text-red-700 dark:bg-red-900/30 dark:text-red-400',\r\n      )\r\n    \"\r\n    @click=\"toggle\"\r\n  >\r\n    <MicIcon v-if=\"state !== 'listening'\" class=\"h-4 w-4\" />\r\n    <div v-else class=\"flex items-center gap-0.5\">\r\n      <div class=\"h-2 w-0.5 animate-bounce bg-current [animation-delay:-0.3s]\" />\r\n      <div class=\"h-3 w-0.5 animate-bounce bg-current [animation-delay:-0.15s]\" />\r\n      <div class=\"h-2 w-0.5 animate-bounce bg-current\" />\r\n    </div>\r\n  </Button>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/core\\context.ts",
      "type": "registry:component",
      "content": "import { inject, provide, ref, computed } from 'vue'\r\nimport type { Editor } from '@tiptap/vue-3'\r\nimport { AI_INPUT_KEY, type AIInputContext, type AttachmentFile, type UploadHandler } from './types'\r\nimport { createContextItemRegistry } from '../extensions/context-item/registry'\r\nimport { CONTEXT_ITEM_REGISTRY_KEY } from '../extensions/context-item/registry/types'\r\nimport { useFileUpload } from '../hooks/use-file-upload'\r\nimport { useEditorState } from '../hooks/use-editor-state'\r\n\r\n/**\r\n * Props for the AIInput component\r\n */\r\nexport interface AIInputProps {\r\n  /**\r\n   * Disable interaction with the input\r\n   */\r\n  disabled?: boolean\r\n  /**\r\n   * Set loading state (disables submission)\r\n   */\r\n  loading?: boolean\r\n  /**\r\n   * Command history for up/down navigation\r\n   */\r\n  history?: string[]\r\n  /**\r\n   * Custom handler for file uploads\r\n   */\r\n  uploadHandler?: UploadHandler\r\n  /**\r\n   * File types to accept (e.g. \"image/*,application/pdf\")\r\n   */\r\n  accept?: string\r\n  /**\r\n   * Max file size in bytes\r\n   */\r\n  maxSize?: number\r\n  /**\r\n   * Max number of files allowed\r\n   */\r\n  maxFiles?: number\r\n  /**\r\n   * Editor placeholder text\r\n   */\r\n  placeholder?: string\r\n  /**\r\n   * Callback when user submits (Enter or button click)\r\n   */\r\n  onSubmit?: (content: string, files: AttachmentFile[]) => void\r\n}\r\n\r\n/**\r\n * Main provider hook for AIInput system.\r\n * Initializes state, editor, and file handling logic.\r\n * \r\n * @param {AIInputProps} props - Component props\r\n * @returns {AIInputContext} The provided context object\r\n */\r\nexport function useAIInputProvider(props: AIInputProps) {\r\n  const fileInputRef = ref<HTMLInputElement | null>(null)\r\n\r\n  // Use the extracted hook for file management\r\n  const {\r\n    files,\r\n    isUploading: isFileUploading,\r\n    addFiles,\r\n    retryUpload,\r\n    removeFile,\r\n    clearFiles,\r\n  } = useFileUpload({\r\n    handler: props.uploadHandler,\r\n    maxSize: props.maxSize,\r\n    maxFiles: props.maxFiles,\r\n    accept: props.accept,\r\n  })\r\n\r\n  const isLoading = computed(() => props.loading ?? false)\r\n  const isUploading = computed(() => isFileUploading.value)\r\n  const isDisabled = computed(() => props.disabled || isLoading.value)\r\n\r\n  // Internal submit handler\r\n  /**\r\n   * Handles the submission of the input.\r\n   * Checks for errors, empty content, and active uploads before calling onSubmit.\r\n   */\r\n  const handleSubmit = () => {\r\n    if (isDisabled.value || isUploading.value) return\r\n\r\n    if (files.value.some((f: any) => f.status === 'error')) {\r\n      return\r\n    }\r\n\r\n    // Editor instance comes from the hook now\r\n    const content = editor.value?.getHTML() || ''\r\n    if (!content && files.value.length === 0) return\r\n\r\n    props.onSubmit?.(content, files.value)\r\n\r\n    editor.value?.commands.clearContent()\r\n    clearFiles()\r\n  }\r\n\r\n  // Use the extracted hook for editor state\r\n  const { editor } = useEditorState({\r\n    history: props.history,\r\n    placeholder: props.placeholder,\r\n    onSubmit: handleSubmit,\r\n    onAddFiles: addFiles,\r\n  })\r\n\r\n  const isEmpty = computed(() => editor.value?.isEmpty ?? true)\r\n  const history = computed(() => props.history || [])\r\n\r\n  // Initialize Registry\r\n  const registry = createContextItemRegistry()\r\n  provide(CONTEXT_ITEM_REGISTRY_KEY, registry)\r\n\r\n  /**\r\n   * Manually set the editor instance (internal use)\r\n   * @param {Editor} instance - The Tiptap editor instance\r\n   */\r\n  const setEditor = (instance: Editor) => {\r\n    // This might be deprecated if we move full control to useEditorState\r\n    editor.value = instance\r\n  }\r\n\r\n  const context: AIInputContext = {\r\n    editor,\r\n    files,\r\n    isUploading,\r\n    isDisabled,\r\n    isEmpty,\r\n    history,\r\n    isLoading,\r\n    fileInputRef,\r\n    setEditor,\r\n    addFiles,\r\n    retryUpload,\r\n    removeFile,\r\n    submit: handleSubmit,\r\n    focus: () => {\r\n      editor.value?.commands.focus()\r\n    },\r\n  }\r\n\r\n  provide(AI_INPUT_KEY, context)\r\n\r\n  return context\r\n}\r\n\r\n/**\r\n * Hook to access the AIInput context\r\n * Must be used within an AIInput component tree\r\n * \r\n * @throws {Error} If used outside of AIInput context\r\n * @returns {AIInputContext} The context object\r\n */\r\nexport function useAIInputContext() {\r\n  const context = inject<AIInputContext>(AI_INPUT_KEY)\r\n  if (!context) {\r\n    throw new Error('useAIInputContext must be used within AIInput')\r\n  }\r\n  return context\r\n}\r\n"
    },
    {
      "path": "ui/ai-input/core\\types.ts",
      "type": "registry:component",
      "content": "import type { Editor } from '@tiptap/vue-3'\r\nimport type { Ref } from 'vue'\r\n\r\n/**\r\n * Result object returned after a successful file upload\r\n */\r\nexport interface UploadResult {\r\n  /** Unique identifier from server */\r\n  id: string\r\n  /** URL to the uploaded file */\r\n  url?: string\r\n  /** File name */\r\n  name: string\r\n  /** MIME type */\r\n  type: string\r\n  // Extendable for other metadata\r\n}\r\n\r\n/**\r\n * Function signature for handling file uploads\r\n * @param {File} file - The file to upload\r\n * @param {function} onProgress - Callback to report upload progress (0-100)\r\n * @returns {Promise<UploadResult>} The result of the upload\r\n */\r\nexport type UploadHandler = (\r\n  file: File,\r\n  onProgress?: (progress: number) => void,\r\n) => Promise<UploadResult>\r\n\r\n/**\r\n * Represents a file attachment in the input\r\n */\r\nexport interface AttachmentFile {\r\n  /** Unique local ID */\r\n  id: string\r\n  /** The original File object (if local) */\r\n  file?: File\r\n  /** MIME type */\r\n  type?: string\r\n  /** File name */\r\n  name?: string\r\n\r\n  // Upload status\r\n  /** Current status of the file upload */\r\n  status: 'pending' | 'uploading' | 'done' | 'error'\r\n  /** Upload progress percentage (0-100) */\r\n  progress: number\r\n  /** Error object if status is 'error' */\r\n  error?: Error\r\n\r\n  // Server data after upload\r\n  /** Data returned from the server after upload */\r\n  serverData?: UploadResult\r\n}\r\n\r\n/**\r\n * Context object provided by AIInput\r\n */\r\nexport interface AIInputContext {\r\n  /** The Tiptap editor instance */\r\n  editor: Ref<Editor | undefined>\r\n  /** List of attached files */\r\n  files: Ref<AttachmentFile[]>\r\n  /** Whether the input is currently loading/submitting */\r\n  isLoading: Ref<boolean>\r\n  /** Whether the input is disabled */\r\n  isDisabled: Ref<boolean>\r\n  /** Reference to the hidden file input element */\r\n  fileInputRef: Ref<HTMLInputElement | null>\r\n\r\n  // Actions\r\n  /** Manually set the editor instance */\r\n  setEditor: (instance: Editor) => void\r\n  /** Add files to the input */\r\n  addFiles: (files: File[] | FileList) => Promise<void>\r\n  /** Remove a file by ID */\r\n  removeFile: (id: string) => void\r\n  /** Submit the input content */\r\n  submit: () => void\r\n  /** Focus the editor */\r\n  focus: () => void\r\n  /** Retry a failed upload */\r\n  retryUpload: (id: string) => void\r\n\r\n  // Helpers\r\n  /** Whether the editor content is empty */\r\n  isEmpty: Ref<boolean>\r\n  /** Command history */\r\n  history: Ref<string[]>\r\n  /** Whether any files are currently uploading */\r\n  isUploading: Ref<boolean>\r\n}\r\n\r\n/** Injection key for AIInputContext */\r\nexport const AI_INPUT_KEY = Symbol('AIInputContext')\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\components\\ContextItemWrapper.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * ContextItemWrapper.vue\r\n * \r\n * Common UI wrapper for all context items.\r\n * Provides the pill-shaped container, icon, label, popover functionality,\r\n * and removal actions.\r\n * \r\n * @component\r\n * @slot default - Content to be displayed in the popover body\r\n * @slot trigger - Custom content for the trigger button (replaces default label)\r\n */\r\nimport { cn } from '@/lib/utils'\r\nimport { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover'\r\nimport { Button } from '@/components/ui/button'\r\nimport { TrashIcon, ExternalLinkIcon } from 'lucide-vue-next'\r\nimport type { Component } from 'vue'\r\n\r\nconst props = defineProps<{\r\n  /** Unique ID of the item */\r\n  id: string\r\n  /** Label text to display */\r\n  label: string\r\n  /** Icon component to display */\r\n  icon?: Component\r\n  /** Type string for display in header */\r\n  type?: string\r\n  /** Metadata object (used for debug/links) */\r\n  metadata?: Record<string, any>\r\n  /** Whether the item is selected */\r\n  selected?: boolean\r\n  /** Whether the item can be closed/removed */\r\n  closable?: boolean\r\n\r\n  /** Callback when remove button is clicked */\r\n  onRemove?: () => void\r\n  /** Callback when popover is opened */\r\n  onOpen?: () => void\r\n}>()\r\n</script>\r\n\r\n<template>\r\n  <Popover>\r\n    <PopoverTrigger as-child>\r\n      <span\r\n        :class=\"\r\n          cn(\r\n            'inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-xs font-medium transition-colors cursor-pointer select-none',\r\n            'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',\r\n            props.selected && 'ring-2 ring-ring',\r\n          )\r\n        \"\r\n      >\r\n        <component :is=\"icon\" v-if=\"icon\" class=\"h-3 w-3 opacity-70\" />\r\n\r\n        <!-- Main Label Slot or Default -->\r\n        <slot name=\"trigger\">\r\n          <span class=\"max-w-[150px] truncate\">{{ label }}</span>\r\n        </slot>\r\n\r\n        <!-- Quick Remove Button (visible on hover or always) -->\r\n        <button\r\n          v-if=\"onRemove\"\r\n          class=\"ml-1 rounded-full p-0.5 hover:bg-muted-foreground/20 focus:outline-none opacity-50 hover:opacity-100\"\r\n          contenteditable=\"false\"\r\n          type=\"button\"\r\n          @click.stop=\"onRemove\"\r\n        >\r\n          <TrashIcon class=\"h-3 w-3\" />\r\n        </button>\r\n      </span>\r\n    </PopoverTrigger>\r\n\r\n    <PopoverContent class=\"w-72 p-0\" align=\"start\">\r\n      <!-- Header -->\r\n      <div class=\"flex items-center justify-between border-b px-3 py-2 bg-muted/30\">\r\n        <div class=\"flex items-center gap-2\">\r\n          <component :is=\"icon\" v-if=\"icon\" class=\"h-3 w-3 text-muted-foreground\" />\r\n          <span class=\"font-medium text-xs\">{{ type || 'Item' }}</span>\r\n        </div>\r\n        <div class=\"flex items-center gap-1\">\r\n          <Button\r\n            v-if=\"onRemove\"\r\n            variant=\"ghost\"\r\n            size=\"icon\"\r\n            class=\"h-6 w-6 text-muted-foreground hover:text-destructive\"\r\n            @click=\"onRemove\"\r\n          >\r\n            <TrashIcon class=\"h-3 w-3\" />\r\n          </Button>\r\n        </div>\r\n      </div>\r\n\r\n      <!-- Body -->\r\n      <div class=\"p-3\">\r\n        <slot />\r\n      </div>\r\n\r\n      <!-- Footer (Metadata Debug or Extra Actions) -->\r\n      <div\r\n        v-if=\"metadata?.url || id\"\r\n        class=\"border-t px-3 py-1.5 bg-muted/10 text-[10px] text-muted-foreground flex justify-between items-center\"\r\n      >\r\n        <span class=\"font-mono opacity-50\">ID: {{ id.slice(0, 6) }}...</span>\r\n        <a\r\n          v-if=\"metadata?.url\"\r\n          :href=\"metadata.url\"\r\n          target=\"_blank\"\r\n          class=\"flex items-center gap-1 hover:underline hover:text-primary\"\r\n        >\r\n          Open Link <ExternalLinkIcon class=\"h-3 w-3\" />\r\n        </a>\r\n      </div>\r\n    </PopoverContent>\r\n  </Popover>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\components\\DefaultContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * DefaultContextItem.vue\r\n * \r\n * Fallback component for context items that don't have a specific renderer.\r\n * Displays basic metadata like size and mime type.\r\n * \r\n * @component\r\n */\r\nimport { FileIcon, HashIcon } from 'lucide-vue-next'\r\nimport { computed } from 'vue'\r\nimport type { ContextItemProps } from '../registry/types'\r\nimport ContextItemWrapper from './ContextItemWrapper.vue'\r\n\r\nconst props = defineProps<ContextItemProps>()\r\n\r\n/**\r\n * Determine icon based on type\r\n */\r\nconst icon = computed(() => {\r\n  if (props.type === 'variable') return HashIcon\r\n  return FileIcon\r\n})\r\n</script>\r\n\r\n<template>\r\n  <ContextItemWrapper\r\n    :id=\"id\"\r\n    :label=\"label\"\r\n    :type=\"type\"\r\n    :icon=\"icon\"\r\n    :metadata=\"metadata\"\r\n    :selected=\"selected\"\r\n    :on-remove=\"deleteNode\"\r\n  >\r\n    <!-- Default content just shows basic info -->\r\n    <div class=\"space-y-2 text-sm\">\r\n      <div class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\r\n        <span class=\"text-muted-foreground\">Label</span>\r\n        <span class=\"font-medium truncate\">{{ label }}</span>\r\n      </div>\r\n      <div v-if=\"metadata?.size\" class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\r\n        <span class=\"text-muted-foreground\">Size</span>\r\n        <span>{{ (metadata.size / 1024).toFixed(1) }} KB</span>\r\n      </div>\r\n      <div v-if=\"metadata?.mimeType\" class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\r\n        <span class=\"text-muted-foreground\">Type</span>\r\n        <span class=\"font-mono text-xs\">{{ metadata.mimeType }}</span>\r\n      </div>\r\n    </div>\r\n  </ContextItemWrapper>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\components\\items\\DateContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * DateContextItem.vue\r\n * \r\n * Context item for selecting and displaying a date.\r\n * Uses a Calendar component in the popover.\r\n * \r\n * @component\r\n */\r\nimport { CalendarIcon } from 'lucide-vue-next'\r\nimport { computed } from 'vue'\r\nimport type { ContextItemProps } from '../../registry/types'\r\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\r\nimport { Calendar } from '@/components/ui/calendar'\r\nimport { type DateValue, getLocalTimeZone, CalendarDate } from '@internationalized/date'\r\n\r\nconst props = defineProps<ContextItemProps>()\r\n\r\n/**\r\n * Parsed current date from metadata\r\n * Metadata structure: { date: string (ISO) }\r\n */\r\nconst currentDate = computed(() => {\r\n  if (!props.metadata?.date) return undefined\r\n  const d = new Date(props.metadata.date)\r\n  // Simple conversion for demo - in production use correct timezone handling\r\n  const year = d.getFullYear()\r\n  const month = d.getMonth() + 1\r\n  const day = d.getDate()\r\n  return new CalendarDate(year, month, day)\r\n})\r\n\r\n/**\r\n * Formatted label for display\r\n */\r\nconst displayLabel = computed(() => {\r\n  return props.metadata?.date \r\n    ? `${props.label}: ${new Date(props.metadata.date).toLocaleDateString()}`\r\n    : `${props.label}: Pick a date`\r\n})\r\n\r\n/**\r\n * Handle date selection from calendar\r\n * Updates the node attributes with ISO string\r\n * \r\n * @param {DateValue | undefined} dateValue - The selected date\r\n */\r\nconst handleSelect = (dateValue: DateValue | undefined) => {\r\n  if (!dateValue) return\r\n  const date = dateValue.toDate(getLocalTimeZone())\r\n  props.updateAttributes({\r\n    metadata: {\r\n      ...props.metadata,\r\n      date: date.toISOString(),\r\n    },\r\n  })\r\n}\r\n</script>\r\n\r\n<template>\r\n  <ContextItemWrapper\r\n    :id=\"id\"\r\n    :label=\"displayLabel\"\r\n    :type=\"type\"\r\n    :icon=\"CalendarIcon\"\r\n    :metadata=\"metadata\"\r\n    :selected=\"selected\"\r\n    :on-remove=\"deleteNode\"\r\n  >\r\n    <div class=\"p-2\">\r\n      <Calendar\r\n        mode=\"single\"\r\n        :model-value=\"currentDate\"\r\n        class=\"rounded-md border\"\r\n        @update:model-value=\"handleSelect\"\r\n      />\r\n    </div>\r\n  </ContextItemWrapper>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\components\\items\\NumberContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * NumberContextItem.vue\r\n * \r\n * Context item for numeric values.\r\n * Provides a slider and input field for editing the value.\r\n * \r\n * @component\r\n */\r\nimport { RulerIcon } from 'lucide-vue-next'\r\nimport { computed, ref, watch } from 'vue'\r\nimport type { ContextItemProps } from '../../registry/types'\r\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\r\nimport { Input } from '@/components/ui/input'\r\nimport { Label } from '@/components/ui/label'\r\nimport { Slider } from '@/components/ui/slider'\r\n\r\nconst props = defineProps<ContextItemProps>()\r\n\r\n// Metadata structure: { value: number, unit: string, min?: number, max?: number, step?: number }\r\n/** Unit of measurement (e.g. 'px', 'em') */\r\nconst unit = computed(() => props.metadata?.unit || '')\r\n/** Minimum value for slider */\r\nconst min = computed(() => props.metadata?.min ?? 0)\r\n/** Maximum value for slider */\r\nconst max = computed(() => props.metadata?.max ?? 100)\r\n/** Step value for slider/input */\r\nconst step = computed(() => props.metadata?.step ?? 1)\r\n\r\n/** Local state for editing to prevent aggressive updates */\r\nconst currentValue = ref(props.metadata?.value ?? 0)\r\n\r\n/**\r\n * Sync local state when props change (external updates)\r\n */\r\nwatch(\r\n  () => props.metadata?.value,\r\n  (val) => {\r\n    if (val !== undefined) currentValue.value = val\r\n  },\r\n  { immediate: true },\r\n)\r\n\r\n/**\r\n * Update the node attributes when value changes\r\n * @param {number} val - The new numeric value\r\n */\r\nconst updateValue = (val: number) => {\r\n  currentValue.value = val\r\n  props.updateAttributes({\r\n    metadata: {\r\n      ...props.metadata,\r\n      value: val,\r\n    },\r\n  })\r\n}\r\n\r\n/**\r\n * Formatted label for display\r\n */\r\nconst displayLabel = computed(() => {\r\n  return `${props.label}: ${currentValue.value}${unit.value ? ' ' + unit.value : ''}`\r\n})\r\n</script>\r\n\r\n<template>\r\n  <ContextItemWrapper\r\n    :id=\"id\"\r\n    :label=\"displayLabel\"\r\n    :type=\"type\"\r\n    :icon=\"RulerIcon\"\r\n    :metadata=\"metadata\"\r\n    :selected=\"selected\"\r\n    :on-remove=\"deleteNode\"\r\n  >\r\n    <div class=\"space-y-4 py-2\">\r\n      <div class=\"space-y-1\">\r\n        <Label class=\"text-xs\">{{ label }} ({{ unit }})</Label>\r\n        <div class=\"flex items-center gap-2\">\r\n          <Input\r\n            type=\"number\"\r\n            :model-value=\"currentValue\"\r\n            :min=\"min\"\r\n            :max=\"max\"\r\n            :step=\"step\"\r\n            class=\"h-8\"\r\n            @update:model-value=\"(v) => updateValue(Number(v))\"\r\n          />\r\n        </div>\r\n      </div>\r\n\r\n      <Slider\r\n        :model-value=\"[currentValue]\"\r\n        :min=\"min\"\r\n        :max=\"max\"\r\n        :step=\"step\"\r\n        @update:model-value=\"(v) => v && updateValue(v[0])\"\r\n      />\r\n    </div>\r\n  </ContextItemWrapper>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\components\\items\\SelectContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * SelectContextItem.vue\r\n * \r\n * Context item for selecting a value from a predefined list.\r\n * Uses a Command component (combobox style) for selection.\r\n * \r\n * @component\r\n */\r\nimport { ListIcon, CheckIcon } from 'lucide-vue-next'\r\nimport { computed } from 'vue'\r\nimport type { ContextItemProps } from '../../registry/types'\r\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\r\nimport {\r\n  Command,\r\n  CommandInput,\r\n  CommandList,\r\n  CommandItem,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n} from '@/components/ui/command'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst props = defineProps<ContextItemProps>()\r\n\r\n// Metadata structure: { value: string, options: { label: string, value: string }[] }\r\n/** Available options for selection */\r\nconst options = computed(() => props.metadata?.options || [])\r\n/** Current selected value */\r\nconst currentValue = computed(() => props.metadata?.value)\r\n\r\n/**\r\n * Find the full option object for the current value\r\n */\r\nconst selectedOption = computed(() =>\r\n  options.value.find((opt: any) => opt.value === currentValue.value),\r\n)\r\n\r\n/**\r\n * Formatted label for display\r\n */\r\nconst displayLabel = computed(() => {\r\n  return `${props.label}: ${selectedOption.value?.label || currentValue.value || 'Select...'}`\r\n})\r\n\r\n/**\r\n * Handle option selection\r\n * @param {string} val - The value of the selected option\r\n */\r\nconst handleSelect = (val: string) => {\r\n  props.updateAttributes({\r\n    metadata: {\r\n      ...props.metadata,\r\n      value: val,\r\n    },\r\n  })\r\n}\r\n</script>\r\n\r\n<template>\r\n  <ContextItemWrapper\r\n    :id=\"id\"\r\n    :label=\"displayLabel\"\r\n    :type=\"type\"\r\n    :icon=\"ListIcon\"\r\n    :metadata=\"metadata\"\r\n    :selected=\"selected\"\r\n    :on-remove=\"deleteNode\"\r\n  >\r\n    <Command class=\"w-full\">\r\n      <CommandInput placeholder=\"Search options...\" class=\"h-8\" />\r\n      <CommandList>\r\n        <CommandEmpty>No option found.</CommandEmpty>\r\n        <CommandGroup>\r\n          <CommandItem\r\n            v-for=\"option in options\"\r\n            :key=\"option.value\"\r\n            :value=\"option.value\"\r\n            @select=\"handleSelect(option.value)\"\r\n          >\r\n            <CheckIcon\r\n              :class=\"\r\n                cn('mr-2 h-4 w-4', currentValue === option.value ? 'opacity-100' : 'opacity-0')\r\n              \"\r\n            />\r\n            {{ option.label }}\r\n          </CommandItem>\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  </ContextItemWrapper>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\ContextItemView.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * ContextItemView.vue\r\n * \r\n * Tiptap Node View for the context item.\r\n * Dynamically resolves and renders the specific component for the context item type\r\n * using the ContextItemRegistry.\r\n * \r\n * @component\r\n */\r\nimport { NodeViewWrapper, nodeViewProps } from '@tiptap/vue-3'\r\nimport { computed, inject } from 'vue'\r\nimport { CONTEXT_ITEM_REGISTRY_KEY } from './registry/types'\r\n\r\nconst props = defineProps(nodeViewProps)\r\n\r\nconst registry = inject(CONTEXT_ITEM_REGISTRY_KEY) as any\r\nconst type = computed(() => props.node.attrs.type)\r\n\r\n// Fallback safely if registry is missing (e.g. usage outside of AIInputProvider)\r\n/**\r\n * Resolved component to render based on item type\r\n */\r\nconst TargetComponent = computed(() => {\r\n  if (!registry) return null\r\n  return registry.getComponent(type.value)\r\n})\r\n</script>\r\n\r\n<template>\r\n  <NodeViewWrapper as=\"span\" class=\"inline-block align-middle mx-1 select-none\">\r\n    <component\r\n      :is=\"TargetComponent\"\r\n      v-if=\"TargetComponent\"\r\n      :id=\"node.attrs.id\"\r\n      :type=\"type\"\r\n      :label=\"node.attrs.label\"\r\n      :metadata=\"node.attrs.metadata\"\r\n      :selected=\"selected\"\r\n      :delete-node=\"deleteNode\"\r\n      :update-attributes=\"updateAttributes\"\r\n    />\r\n    <span v-else class=\"text-destructive text-xs border border-destructive px-1 rounded\"\r\n      >[Unknown: {{ type }}]</span\r\n    >\r\n  </NodeViewWrapper>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\index.ts",
      "type": "registry:component",
      "content": "import { Node, mergeAttributes } from '@tiptap/core'\r\nimport { VueNodeViewRenderer } from '@tiptap/vue-3'\r\nimport ContextItemView from './ContextItemView.vue'\r\n\r\n/**\r\n * ContextItem Extension for Tiptap\r\n * \r\n * Defines a custom 'contextItem' node that renders as an inline block.\r\n * Uses a Vue Node View to render dynamic content based on the item type.\r\n */\r\nexport const ContextItem = Node.create({\r\n  name: 'contextItem',\r\n  group: 'inline',\r\n  inline: true,\r\n  atom: true,\r\n\r\n  /**\r\n   * Define attributes for the node\r\n   */\r\n  addAttributes() {\r\n    return {\r\n      id: {\r\n        default: null,\r\n      },\r\n      type: {\r\n        default: 'file',\r\n      },\r\n      label: {\r\n        default: 'Context Item',\r\n      },\r\n      metadata: {\r\n        default: {},\r\n      },\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Parse HTML definition\r\n   */\r\n  parseHTML() {\r\n    return [\r\n      {\r\n        tag: 'context-item',\r\n      },\r\n    ]\r\n  },\r\n\r\n  /**\r\n   * Render HTML definition\r\n   */\r\n  renderHTML({ HTMLAttributes }) {\r\n    return ['context-item', mergeAttributes(HTMLAttributes)]\r\n  },\r\n\r\n  /**\r\n   * Attach the Vue Node View\r\n   */\r\n  addNodeView() {\r\n    return VueNodeViewRenderer(ContextItemView)\r\n  },\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\registry\\index.ts",
      "type": "registry:component",
      "content": "import { reactive, defineAsyncComponent, type AsyncComponentLoader } from 'vue'\r\nimport type { ContextItemRegistry, ContextItemComponent, RegistryItem } from './types'\r\nimport DefaultContextItem from '../components/DefaultContextItem.vue'\r\nimport NumberContextItem from '../components/items/NumberContextItem.vue'\r\nimport SelectContextItem from '../components/items/SelectContextItem.vue'\r\nimport DateContextItem from '../components/items/DateContextItem.vue'\r\n\r\n/**\r\n * Creates and initializes the Context Item Registry.\r\n * Registers default item types (default, number, select, date).\r\n * \r\n * @returns {ContextItemRegistry} The initialized registry instance\r\n */\r\nexport function createContextItemRegistry(): ContextItemRegistry {\r\n  const items = reactive<Record<string, RegistryItem>>({\r\n    default: { component: DefaultContextItem },\r\n    number: { component: NumberContextItem },\r\n    select: { component: SelectContextItem },\r\n    date: { component: DateContextItem },\r\n  })\r\n\r\n  /**\r\n   * Register a new component for a specific type\r\n   * @param {string} type - The unique type identifier\r\n   * @param {ContextItemComponent | RegistryItem} item - The component or registry item\r\n   */\r\n  const register = (type: string, item: ContextItemComponent | RegistryItem) => {\r\n    if ('component' in (item as any)) {\r\n      items[type] = item as RegistryItem\r\n    } else {\r\n      items[type] = { component: item as ContextItemComponent }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve a registry item by type\r\n   * @param {string} type - The type to look up\r\n   * @returns {RegistryItem | undefined} The registry item or default if not found\r\n   */\r\n  const get = (type: string) => {\r\n    return items[type] || items['default']\r\n  }\r\n\r\n  /**\r\n   * Get the Vue component for a specific type\r\n   * Handles async component loading automatically\r\n   * \r\n   * @param {string} type - The type to look up\r\n   * @returns {ContextItemComponent | AsyncComponentLoader | undefined} The Vue component\r\n   */\r\n  const getComponent = (type: string): ContextItemComponent | AsyncComponentLoader | undefined => {\r\n    const item = get(type)\r\n    if (!item) return undefined\r\n\r\n    // Check if it's an async component loader (function)\r\n    if (typeof item.component === 'function' && !('render' in item.component)) {\r\n      return defineAsyncComponent(item.component as any) as unknown as AsyncComponentLoader\r\n    }\r\n\r\n    return item.component as ContextItemComponent\r\n  }\r\n\r\n  return {\r\n    register,\r\n    get,\r\n    getComponent,\r\n  }\r\n}\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\context-item\\registry\\types.ts",
      "type": "registry:component",
      "content": "import type { Component, AsyncComponentLoader } from 'vue'\r\n\r\n/**\r\n * Props passed to a Context Item component\r\n */\r\nexport interface ContextItemProps {\r\n  /** Unique identifier for the item */\r\n  id: string\r\n  /** Display label for the item */\r\n  label: string\r\n  /** Type of the context item (e.g. 'file', 'date') */\r\n  type: string\r\n  /** Additional metadata for the item */\r\n  metadata?: Record<string, any>\r\n\r\n  /** Whether the item is currently selected in the editor */\r\n  selected: boolean\r\n\r\n  /** Function to delete this node from the editor */\r\n  deleteNode: () => void\r\n  /** Function to update the node's attributes */\r\n  updateAttributes: (attrs: Record<string, any>) => void\r\n}\r\n\r\n/**\r\n * Definition of a Context Item Vue component\r\n */\r\nexport type ContextItemComponent = Component<ContextItemProps>\r\n\r\n/**\r\n * Registry item entry definition\r\n */\r\nexport interface RegistryItem {\r\n  /** The Vue component to render */\r\n  component: ContextItemComponent | AsyncComponentLoader\r\n  /** Optional metadata for the registry item */\r\n  meta?: {\r\n    label?: string\r\n    icon?: Component\r\n  }\r\n}\r\n\r\n/**\r\n * Interface for the Context Item Registry\r\n */\r\nexport interface ContextItemRegistry {\r\n  /** Register a new context item type */\r\n  register: (type: string, item: ContextItemComponent | RegistryItem) => void\r\n  /** Get a registry item by type */\r\n  get: (type: string) => RegistryItem | undefined\r\n  /** Get the component for a specific type */\r\n  getComponent: (type: string) => ContextItemComponent | AsyncComponentLoader | undefined\r\n}\r\n\r\n/** Injection key for the Context Item Registry */\r\nexport const CONTEXT_ITEM_REGISTRY_KEY = Symbol('CONTEXT_ITEM_REGISTRY_KEY')\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\file-handler\\index.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\r\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\r\n\r\n/**\r\n * Options for the FileHandler extension\r\n */\r\nexport interface FileHandlerOptions {\r\n  /** Callback when files are dropped into the editor */\r\n  onDrop?: (files: File[], pos: number) => void\r\n  /** Callback when files are pasted */\r\n  onPaste?: (files: File[]) => void\r\n  /** Callback when internal reference items are dropped */\r\n  onReferenceDrop?: (data: any, pos: number) => void\r\n}\r\n\r\n/**\r\n * FileHandler Extension\r\n * \r\n * Handles drag-and-drop and paste events for files.\r\n * Also manages internal drag-and-drop for reference items.\r\n */\r\nexport const FileHandler = Extension.create<FileHandlerOptions>({\r\n  name: 'fileHandler',\r\n\r\n  addOptions() {\r\n    return {\r\n      onDrop: undefined,\r\n      onPaste: undefined,\r\n      onReferenceDrop: undefined,\r\n    }\r\n  },\r\n\r\n  addProseMirrorPlugins() {\r\n    return [\r\n      new Plugin({\r\n        key: new PluginKey('fileHandler'),\r\n        props: {\r\n          handleDrop: (view, event, _slice, moved) => {\r\n            if (moved) return false\r\n\r\n            const dataTransfer = event.dataTransfer\r\n            if (!dataTransfer) return false\r\n\r\n            // 1. Check for Internal Reference Drop (Custom MIME type)\r\n            // We use 'application/x-ai-ref' to identify our own draggable items\r\n            const refData = dataTransfer.getData('application/x-ai-ref')\r\n            if (refData) {\r\n              event.preventDefault()\r\n              try {\r\n                const parsed = JSON.parse(refData)\r\n                const coords = { left: event.clientX, top: event.clientY }\r\n                const pos = view.posAtCoords(coords)?.pos || view.state.selection.from\r\n\r\n                if (this.options.onReferenceDrop) {\r\n                  this.options.onReferenceDrop(parsed, pos)\r\n                }\r\n                return true\r\n              } catch (e) {\r\n                console.error('Failed to parse reference drop data', e)\r\n              }\r\n            }\r\n\r\n            // 2. Check for Files\r\n            const hasFiles = dataTransfer.files?.length\r\n            if (hasFiles) {\r\n              event.preventDefault()\r\n              const files = Array.from(dataTransfer.files)\r\n              const coords = { left: event.clientX, top: event.clientY }\r\n              const pos = view.posAtCoords(coords)?.pos || view.state.selection.from\r\n\r\n              if (this.options.onDrop) {\r\n                this.options.onDrop(files, pos)\r\n              }\r\n              return true\r\n            }\r\n\r\n            return false\r\n          },\r\n          handlePaste: (_view, event) => {\r\n            const items = event.clipboardData?.items\r\n            if (!items) return false\r\n\r\n            const files: File[] = []\r\n            for (const item of Array.from(items)) {\r\n              if (item.kind === 'file') {\r\n                const file = item.getAsFile()\r\n                if (file) files.push(file)\r\n              }\r\n            }\r\n\r\n            if (files.length > 0) {\r\n              event.preventDefault()\r\n              if (this.options.onPaste) {\r\n                this.options.onPaste(files)\r\n              }\r\n              return true\r\n            }\r\n            return false\r\n          },\r\n        },\r\n      }),\r\n    ]\r\n  },\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\history\\index.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\r\n\r\n/**\r\n * Options for History Navigation extension\r\n */\r\nexport interface HistoryNavigationOptions {\r\n  /** Handler for Up arrow key */\r\n  onUp?: () => boolean\r\n  /** Handler for Down arrow key */\r\n  onDown?: () => boolean\r\n}\r\n\r\n/**\r\n * HistoryNavigation Extension\r\n * \r\n * Manages keyboard shortcuts for navigating through command history (Up/Down arrows).\r\n * Logic is delegated to the provided callbacks.\r\n */\r\nexport const HistoryNavigation = Extension.create<HistoryNavigationOptions>({\r\n  name: 'historyNavigation',\r\n\r\n  addOptions() {\r\n    return {\r\n      onUp: undefined,\r\n      onDown: undefined,\r\n    }\r\n  },\r\n\r\n  addKeyboardShortcuts() {\r\n    return {\r\n      // ArrowUp: ({ editor }) => { ... }\r\n      // We moved this logic to useEditorState options for better Reactivity\r\n    }\r\n  },\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\mention\\MentionList.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * MentionList.vue\r\n * \r\n * Component to display the list of mention suggestions.\r\n * Handles keyboard navigation (Up/Down/Enter) and selection.\r\n * \r\n * @component\r\n */\r\nimport { ref, watch } from 'vue'\r\nimport { cn } from '@/lib/utils'\r\nimport { FileIcon } from 'lucide-vue-next'\r\n\r\ninterface Item {\r\n  id: string\r\n  label: string\r\n}\r\n\r\ninterface Props {\r\n  items: Item[]\r\n  command: (props: any) => void\r\n}\r\n\r\nconst props = defineProps<Props>()\r\n\r\nconst selectedIndex = ref(0)\r\n\r\nwatch(\r\n  () => props.items,\r\n  () => {\r\n    selectedIndex.value = 0\r\n  },\r\n)\r\n\r\nconst selectItem = (index: number) => {\r\n  const item = props.items[index]\r\n  if (item) {\r\n    props.command({ id: item.id, label: item.label })\r\n  }\r\n}\r\n\r\n/**\r\n * Handle keyboard events delegated from Tiptap\r\n */\r\nconst onKeyDown = ({ event }: { event: KeyboardEvent }) => {\r\n  if (event.key === 'ArrowUp') {\r\n    selectedIndex.value = (selectedIndex.value + props.items.length - 1) % props.items.length\r\n    return true\r\n  }\r\n\r\n  if (event.key === 'ArrowDown') {\r\n    selectedIndex.value = (selectedIndex.value + 1) % props.items.length\r\n    return true\r\n  }\r\n\r\n  if (event.key === 'Enter') {\r\n    selectItem(selectedIndex.value)\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\ndefineExpose({\r\n  onKeyDown,\r\n})\r\n</script>\r\n\r\n<template>\r\n  <div\r\n    class=\"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95\"\r\n  >\r\n    <div\r\n      v-for=\"(item, index) in items\"\r\n      :key=\"index\"\r\n      :class=\"\r\n        cn(\r\n          'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors',\r\n          index === selectedIndex ? 'bg-accent text-accent-foreground' : 'hover:bg-accent/50',\r\n        )\r\n      \"\r\n      @click=\"selectItem(index)\"\r\n    >\r\n      <FileIcon class=\"mr-2 h-4 w-4 text-muted-foreground\" />\r\n      <span>{{ item.label }}</span>\r\n    </div>\r\n    <div v-if=\"items.length === 0\" class=\"p-2 text-sm text-muted-foreground\">No results</div>\r\n  </div>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\mention\\suggestion.ts",
      "type": "registry:component",
      "content": "import { VueRenderer } from '@tiptap/vue-3'\r\nimport tippy from 'tippy.js'\r\nimport MentionList from './MentionList.vue'\r\n\r\n/**\r\n * Configuration for Tiptap Mention extension suggestion utility.\r\n * Handles the popup rendering and item filtering.\r\n */\r\nexport default {\r\n  /**\r\n   * Filter items based on query\r\n   */\r\n  items: ({ query }: { query: string }) => {\r\n    // Mock data\r\n    return [\r\n      { id: '1', label: 'App.vue' },\r\n      { id: '2', label: 'main.ts' },\r\n      { id: '3', label: 'utils.ts' },\r\n      { id: '4', label: 'api.ts' },\r\n      { id: '5', label: 'router.ts' },\r\n      { id: '6', label: 'AIInput.vue' },\r\n    ].filter((item) => item.label.toLowerCase().includes(query.toLowerCase()))\r\n  },\r\n\r\n  /**\r\n   * Execution command when an item is selected\r\n   */\r\n  command: ({ editor, range, props }: any) => {\r\n    // Increase range.to by one when the next node is of type \"text\"\r\n    // and starts with a space character\r\n    const nodeAfter = editor.view.state.selection.$to.nodeAfter\r\n    const overrideSpace = nodeAfter?.text?.startsWith(' ')\r\n\r\n    if (overrideSpace) {\r\n      range.to += 1\r\n    }\r\n\r\n    editor\r\n      .chain()\r\n      .focus()\r\n      .insertContentAt(range, [\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            id: props.id,\r\n            label: props.label,\r\n            type: 'file', // Default type for now\r\n          },\r\n        },\r\n        {\r\n          type: 'text',\r\n          text: ' ',\r\n        },\r\n      ])\r\n      .run()\r\n\r\n    window.getSelection()?.collapseToEnd()\r\n  },\r\n\r\n  /**\r\n   * Renderer configuration for the popup\r\n   */\r\n  render: () => {\r\n    let component: VueRenderer\r\n    let popup: any\r\n\r\n    return {\r\n      onStart: (props: any) => {\r\n        component = new VueRenderer(MentionList, {\r\n          props,\r\n          editor: props.editor,\r\n        })\r\n\r\n        if (!props.clientRect) {\r\n          return\r\n        }\r\n\r\n        popup = tippy(document.body as any, {\r\n          getReferenceClientRect: props.clientRect,\r\n          appendTo: () => document.body,\r\n          content: component.element as any,\r\n          showOnCreate: true,\r\n          interactive: true,\r\n          trigger: 'manual',\r\n          placement: 'bottom-start',\r\n        })\r\n      },\r\n\r\n      onUpdate: (props: any) => {\r\n        component.updateProps(props)\r\n\r\n        if (!props.clientRect) {\r\n          return\r\n        }\r\n\r\n        popup[0].setProps({\r\n          getReferenceClientRect: props.clientRect,\r\n        })\r\n      },\r\n\r\n      onKeyDown: (props: any) => {\r\n        if (props.event.key === 'Escape') {\r\n          popup[0].hide()\r\n          return true\r\n        }\r\n\r\n        return component.ref?.onKeyDown(props)\r\n      },\r\n\r\n      onExit: () => {\r\n        popup[0].destroy()\r\n        component.destroy()\r\n      },\r\n    }\r\n  },\r\n}\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\slash-command\\CommandList.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\r\n/**\r\n * CommandList.vue\r\n * \r\n * Component to display the list of available slash commands.\r\n * Handles keyboard navigation and selection.\r\n * \r\n * @component\r\n */\r\nimport { ref, watch } from 'vue'\r\nimport { cn } from '@/lib/utils'\r\nimport type { PromptShortcut } from './types'\r\n\r\nconst props = defineProps<{\r\n  /** List of filtered shortcuts */\r\n  items: PromptShortcut[]\r\n  /** Command execution callback */\r\n  command: (item: PromptShortcut) => void\r\n}>()\r\n\r\nconst selectedIndex = ref(0)\r\n\r\nwatch(\r\n  () => props.items,\r\n  () => {\r\n    selectedIndex.value = 0\r\n  },\r\n)\r\n\r\n/**\r\n * Handle keyboard navigation events from Tiptap\r\n */\r\nconst onKeyDown = ({ event }: { event: KeyboardEvent }) => {\r\n  if (event.key === 'ArrowUp') {\r\n    selectedIndex.value = (selectedIndex.value + props.items.length - 1) % props.items.length\r\n    return true\r\n  }\r\n\r\n  if (event.key === 'ArrowDown') {\r\n    selectedIndex.value = (selectedIndex.value + 1) % props.items.length\r\n    return true\r\n  }\r\n\r\n  if (event.key === 'Enter') {\r\n    selectItem(selectedIndex.value)\r\n    return true\r\n  }\r\n\r\n  if (event.key === 'Tab') {\r\n    event.preventDefault()\r\n    event.stopPropagation()\r\n    selectItem(selectedIndex.value)\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nconst selectItem = (index: number) => {\r\n  const item = props.items[index]\r\n  if (item) {\r\n    props.command(item)\r\n  }\r\n}\r\n\r\ndefineExpose({\r\n  onKeyDown,\r\n})\r\n</script>\r\n\r\n<template>\r\n  <div\r\n    class=\"z-50 min-w-[300px] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95\"\r\n  >\r\n    <div v-if=\"items.length === 0\" class=\"p-2 text-sm text-muted-foreground text-center\">\r\n      No commands found\r\n    </div>\r\n\r\n    <div\r\n      v-for=\"(item, index) in items\"\r\n      :key=\"index\"\r\n      :class=\"\r\n        cn(\r\n          'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none',\r\n          index === selectedIndex ? 'bg-accent text-accent-foreground' : '',\r\n        )\r\n      \"\r\n      @click=\"selectItem(index)\"\r\n      @mouseenter=\"selectedIndex = index\"\r\n    >\r\n      <component :is=\"item.icon\" v-if=\"item.icon\" class=\"mr-2 h-4 w-4\" />\r\n      <div class=\"flex flex-col flex-1 gap-0.5\">\r\n        <span class=\"font-medium\">{{ item.label }}</span>\r\n        <span v-if=\"item.description\" class=\"text-xs text-muted-foreground/80 truncate\">\r\n          {{ item.description }}\r\n        </span>\r\n      </div>\r\n      <kbd\r\n        v-if=\"index === selectedIndex\"\r\n        class=\"ml-auto text-[10px] text-muted-foreground font-mono bg-muted px-1 rounded\"\r\n      >\r\n        \r\n      </kbd>\r\n    </div>\r\n  </div>\r\n</template>\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\slash-command\\index.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\r\nimport Suggestion from '@tiptap/suggestion'\r\nimport { VueRenderer } from '@tiptap/vue-3'\r\nimport tippy from 'tippy.js'\r\nimport CommandList from './CommandList.vue'\r\nimport type { SlashCommandOptions, PromptShortcut } from './types'\r\nimport { defaultShortcuts } from './shortcuts'\r\nimport { PluginKey } from '@tiptap/pm/state'\r\n\r\n/**\r\n * SlashCommand Extension\r\n * \r\n * Provides a slash command menu (\"/\") triggered by the Suggestion utility.\r\n * Allows inserting templates and complex nodes via shortcuts.\r\n */\r\nexport const SlashCommand = Extension.create<SlashCommandOptions>({\r\n  name: 'slashCommand',\r\n\r\n  addOptions() {\r\n    return {\r\n      char: '/',\r\n      shortcuts: defaultShortcuts,\r\n    }\r\n  },\r\n\r\n  addProseMirrorPlugins() {\r\n    return [\r\n      Suggestion({\r\n        editor: this.editor,\r\n        char: this.options.char,\r\n        pluginKey: new PluginKey('slashCommand'), // Explicit key to separate from Mentions\r\n\r\n        items: ({ query }) => {\r\n          return this.options.shortcuts\r\n            .filter(\r\n              (item) =>\r\n                item.label.toLowerCase().includes(query.toLowerCase()) ||\r\n                item.key.toLowerCase().includes(query.toLowerCase()),\r\n            )\r\n            .slice(0, 10)\r\n        },\r\n\r\n        command: ({ editor, range, props }) => {\r\n          const item = props as PromptShortcut\r\n\r\n          // Delete the slash command text\r\n          editor.chain().focus().deleteRange(range).run()\r\n\r\n          // Insert the template content\r\n          // If template is a function, call it (future proofing for dynamic templates)\r\n          const content = typeof item.template === 'function' ? item.template() : item.template\r\n\r\n          // We need to unwrap the 'doc' if it exists, as insertContent expects nodes/array\r\n          const nodesToInsert =\r\n            content.type === 'doc' && content.content ? content.content : content\r\n\r\n          editor.chain().insertContent(nodesToInsert).run()\r\n        },\r\n\r\n        render: () => {\r\n          let component: VueRenderer\r\n          let popup: any\r\n\r\n          return {\r\n            onStart: (props) => {\r\n              component = new VueRenderer(this.options.component || CommandList, {\r\n                props,\r\n                editor: props.editor,\r\n              })\r\n\r\n              if (!props.clientRect) {\r\n                return\r\n              }\r\n\r\n              popup = tippy(document.body as any, {\r\n                getReferenceClientRect: props.clientRect as any,\r\n                appendTo: () => document.body,\r\n                content: component.element as any,\r\n                showOnCreate: true,\r\n                interactive: true,\r\n                trigger: 'manual',\r\n                placement: 'bottom-start',\r\n                zIndex: 9999, // Ensure it's above other elements\r\n              })\r\n            },\r\n\r\n            onUpdate: (props) => {\r\n              component.updateProps(props)\r\n\r\n              if (!props.clientRect) {\r\n                return\r\n              }\r\n\r\n              popup.setProps({\r\n                getReferenceClientRect: props.clientRect,\r\n              })\r\n            },\r\n\r\n            onKeyDown: (props) => {\r\n              if (props.event.key === 'Escape') {\r\n                popup.hide()\r\n                return true\r\n              }\r\n              // @ts-ignore\r\n              return component.ref?.onKeyDown(props)\r\n            },\r\n\r\n            onExit: () => {\r\n              popup.destroy()\r\n              component.destroy()\r\n            },\r\n          }\r\n        },\r\n      }),\r\n    ]\r\n  },\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\slash-command\\shortcuts.ts",
      "type": "registry:component",
      "content": "import { BugIcon, DatabaseIcon, CodeIcon, SparklesIcon } from 'lucide-vue-next'\r\nimport type { PromptShortcut } from './types'\r\n\r\n/**\r\n * Default list of slash commands available in the editor.\r\n * Includes templates for Bug Analysis, SQL Generation, Refactoring, and Explanation.\r\n */\r\nexport const defaultShortcuts: PromptShortcut[] = [\r\n  {\r\n    key: 'bug',\r\n    label: 'Bug Analysis',\r\n    description: 'Analyze code for potential bugs and security issues',\r\n    icon: BugIcon,\r\n    template: {\r\n      type: 'doc',\r\n      content: [\r\n        { type: 'text', text: 'Please analyze the following code for bugs: ' },\r\n        { type: 'hardBreak' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'input',\r\n            label: 'Paste Code Here',\r\n            metadata: { placeholder: 'Code snippet...' },\r\n          },\r\n        },\r\n        { type: 'hardBreak' },\r\n        { type: 'text', text: 'Focus on: ' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'select',\r\n            label: 'Focus Area',\r\n            metadata: {\r\n              value: 'security',\r\n              options: [\r\n                { label: 'Security', value: 'security' },\r\n                { label: 'Performance', value: 'performance' },\r\n                { label: 'Logic', value: 'logic' },\r\n              ],\r\n            },\r\n          },\r\n        },\r\n        { type: 'text', text: ' ' },\r\n      ],\r\n    },\r\n  },\r\n  {\r\n    key: 'sql',\r\n    label: 'SQL Generator',\r\n    description: 'Generate SQL queries for specific databases',\r\n    icon: DatabaseIcon,\r\n    template: {\r\n      type: 'doc',\r\n      content: [\r\n        { type: 'text', text: 'Generate a SQL query for ' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'select',\r\n            label: 'Database',\r\n            metadata: {\r\n              value: 'postgresql',\r\n              options: [\r\n                { label: 'PostgreSQL', value: 'postgresql' },\r\n                { label: 'MySQL', value: 'mysql' },\r\n                { label: 'Oracle', value: 'oracle' },\r\n              ],\r\n            },\r\n          },\r\n        },\r\n        { type: 'text', text: ' to: ' },\r\n        { type: 'hardBreak' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'input',\r\n            label: 'Requirement',\r\n            metadata: { placeholder: 'Describe what you need...' },\r\n          },\r\n        },\r\n        { type: 'text', text: ' ' },\r\n      ],\r\n    },\r\n  },\r\n  {\r\n    key: 'refactor',\r\n    label: 'Refactor Code',\r\n    description: 'Improve code quality and readability',\r\n    icon: SparklesIcon,\r\n    template: {\r\n      type: 'doc',\r\n      content: [\r\n        { type: 'text', text: 'Refactor this code to be more ' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'select',\r\n            label: 'Goal',\r\n            metadata: {\r\n              value: 'readable',\r\n              options: [\r\n                { label: 'Readable', value: 'readable' },\r\n                { label: 'Efficient', value: 'efficient' },\r\n                { label: 'Modern', value: 'modern' },\r\n              ],\r\n            },\r\n          },\r\n        },\r\n        { type: 'text', text: ':' },\r\n        { type: 'hardBreak' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'input',\r\n            label: 'Code',\r\n            metadata: { placeholder: 'Code...' },\r\n          },\r\n        },\r\n        { type: 'text', text: ' ' },\r\n      ],\r\n    },\r\n  },\r\n  {\r\n    key: 'explain',\r\n    label: 'Explain Code',\r\n    description: 'Explain what a piece of code does',\r\n    icon: CodeIcon,\r\n    template: {\r\n      type: 'doc',\r\n      content: [\r\n        { type: 'text', text: 'Explain what this code does in ' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'select',\r\n            label: 'Language',\r\n            metadata: {\r\n              value: 'english',\r\n              options: [\r\n                { label: 'English', value: 'english' },\r\n                { label: 'Chinese', value: 'chinese' },\r\n                { label: 'Japanese', value: 'japanese' },\r\n              ],\r\n            },\r\n          },\r\n        },\r\n        { type: 'text', text: ':' },\r\n        { type: 'hardBreak' },\r\n        {\r\n          type: 'contextItem',\r\n          attrs: {\r\n            type: 'input',\r\n            label: 'Code',\r\n            metadata: { placeholder: 'Paste code...' },\r\n          },\r\n        },\r\n        { type: 'text', text: ' ' },\r\n      ],\r\n    },\r\n  },\r\n]\r\n"
    },
    {
      "path": "ui/ai-input/extensions\\slash-command\\types.ts",
      "type": "registry:component",
      "content": "import type { Component } from 'vue'\r\nimport type { JSONContent } from '@tiptap/core'\r\n\r\n/**\r\n * Definition of a Slash Command shortcut\r\n */\r\nexport interface PromptShortcut {\r\n  /** Trigger key (e.g. 'bug', 'sql') */\r\n  key: string\r\n  /** Display label in menu */\r\n  label: string\r\n  /** Description in menu */\r\n  description?: string\r\n  /** Icon component */\r\n  icon?: Component\r\n\r\n  /**\r\n   * The content to insert when the command is selected.\r\n   * Can be a JSONContent object or a function that returns one.\r\n   */\r\n  template: JSONContent | ((args?: any) => JSONContent)\r\n}\r\n\r\n/**\r\n * Options for Slash Command extension\r\n */\r\nexport interface SlashCommandOptions {\r\n  /** Trigger character (default: '/') */\r\n  char: string\r\n  /** List of available shortcuts */\r\n  shortcuts: PromptShortcut[]\r\n  /** Custom component for the command list menu */\r\n  component?: Component\r\n}"
    },
    {
      "path": "ui/ai-input/hooks\\use-editor-state.ts",
      "type": "registry:component",
      "content": "import { ref, computed, onBeforeUnmount } from 'vue'\r\nimport { useEditor, Extension } from '@tiptap/vue-3'\r\nimport StarterKit from '@tiptap/starter-kit'\r\nimport Placeholder from '@tiptap/extension-placeholder'\r\nimport Mention from '@tiptap/extension-mention'\r\nimport { ContextItem } from '../extensions/context-item'\r\nimport { FileHandler } from '../extensions/file-handler'\r\nimport { HistoryNavigation } from '../extensions/history'\r\nimport mentionSuggestion from '../extensions/mention/suggestion'\r\nimport { SlashCommand } from '../extensions/slash-command'\r\nimport type { AnyExtension } from '@tiptap/core'\r\n\r\n/**\r\n * Localization options for the editor\r\n */\r\nexport interface Locale {\r\n  placeholder: string\r\n}\r\n\r\n/**\r\n * Default localization settings\r\n */\r\nexport const defaultLocale: Locale = {\r\n  placeholder: 'Ask AI anything... (Type @ for mention, / for templates)',\r\n}\r\n\r\n/**\r\n * Options for initializing the editor state\r\n */\r\nexport interface UseEditorStateOptions {\r\n  /** Command history for navigation */\r\n  history?: string[]\r\n  /** Placeholder text */\r\n  placeholder?: string\r\n  /** Localization overrides */\r\n  locale?: Partial<Locale>\r\n  /** Callback on submit (Enter key) */\r\n  onSubmit?: () => void\r\n  /** Callback when files are added (paste/drop) */\r\n  onAddFiles?: (files: File[]) => void\r\n  /** Custom extension configuration */\r\n  extensions?: (defaultExtensions: AnyExtension[]) => AnyExtension[]\r\n}\r\n\r\n/**\r\n * Hook to manage Tiptap editor instance and configuration.\r\n * Sets up all extensions including Mentions, Slash Commands, File Handling, etc.\r\n * \r\n * @param {UseEditorStateOptions} options - Configuration options\r\n * @returns {Object} Object containing the editor instance\r\n */\r\nexport function useEditorState(options: UseEditorStateOptions = {}) {\r\n  const historyIndex = ref(-1)\r\n  const draft = ref('')\r\n\r\n  const locale = computed(() => ({\r\n    ...defaultLocale,\r\n    ...options.locale,\r\n  }))\r\n\r\n  // Define SubmitShortcut extension locally\r\n  /**\r\n   * Custom extension to handle Enter key submission\r\n   */\r\n  const SubmitShortcut = Extension.create({\r\n    name: 'submitShortcut',\r\n    priority: 0,\r\n    addKeyboardShortcuts() {\r\n      return {\r\n        Enter: () => {\r\n          if (document.querySelector('.tippy-box[data-state=\"visible\"]')) {\r\n            return false\r\n          }\r\n          options.onSubmit?.()\r\n          return true\r\n        },\r\n      }\r\n    },\r\n  })\r\n\r\n  /**\r\n   * Configure default extensions\r\n   */\r\n  const getDefaultExtensions = () => [\r\n    StarterKit,\r\n    Placeholder.configure({\r\n      placeholder: options.placeholder || locale.value.placeholder,\r\n      emptyEditorClass: 'is-editor-empty',\r\n    }),\r\n    ContextItem,\r\n    FileHandler.configure({\r\n      onDrop: (files: File[]) => {\r\n        options.onAddFiles?.(files)\r\n      },\r\n      onPaste: (files: File[]) => {\r\n        options.onAddFiles?.(files)\r\n      },\r\n      onReferenceDrop: (refData: any, pos: number) => {\r\n        editor.value\r\n          ?.chain()\r\n          .focus()\r\n          .insertContentAt(pos, {\r\n            type: 'contextItem',\r\n            attrs: {\r\n              id: refData.id,\r\n              label: refData.name,\r\n              type: 'file',\r\n              metadata: { originalType: refData.type },\r\n            },\r\n          })\r\n          .run()\r\n      },\r\n    }),\r\n    HistoryNavigation.configure({\r\n      onUp: () => {\r\n        const history = options.history || []\r\n        if (!history.length) return false\r\n\r\n        if (historyIndex.value === -1) {\r\n          draft.value = editor.value?.getHTML() || ''\r\n        }\r\n\r\n        const nextIndex = historyIndex.value + 1\r\n        if (nextIndex < history.length) {\r\n          historyIndex.value = nextIndex\r\n          const item = history[history.length - 1 - nextIndex]\r\n          editor.value?.commands.setContent(item)\r\n          editor.value?.commands.focus('end')\r\n          return true\r\n        }\r\n        return false\r\n      },\r\n      onDown: () => {\r\n        if (historyIndex.value > -1) {\r\n          const nextIndex = historyIndex.value - 1\r\n          historyIndex.value = nextIndex\r\n\r\n          const history = options.history || []\r\n\r\n          if (nextIndex === -1) {\r\n            editor.value?.commands.setContent(draft.value)\r\n          } else {\r\n            const item = history[history.length - 1 - nextIndex]\r\n            editor.value?.commands.setContent(item)\r\n          }\r\n          editor.value?.commands.focus('end')\r\n          return true\r\n        }\r\n        return false\r\n      },\r\n    }),\r\n    SlashCommand,\r\n    Mention.configure({\r\n      HTMLAttributes: {\r\n        class: 'mention',\r\n      },\r\n      suggestion: mentionSuggestion,\r\n    }),\r\n    SubmitShortcut,\r\n  ]\r\n\r\n  const extensions = computed(() => {\r\n    const defaults = getDefaultExtensions() as AnyExtension[]\r\n    return options.extensions ? options.extensions(defaults) : defaults\r\n  })\r\n\r\n  const editor = useEditor({\r\n    extensions: extensions.value,\r\n    editorProps: {\r\n      attributes: {\r\n        class:\r\n          'prose prose-sm dark:prose-invert max-w-none focus:outline-none min-h-[60px] max-h-[200px] overflow-y-auto px-4 py-3',\r\n      },\r\n    },\r\n  })\r\n\r\n  // Cleanup\r\n  onBeforeUnmount(() => {\r\n    editor.value?.destroy()\r\n  })\r\n\r\n  return {\r\n    editor,\r\n  }\r\n}\r\n"
    },
    {
      "path": "ui/ai-input/hooks\\use-file-upload.ts",
      "type": "registry:component",
      "content": "import { ref, computed } from 'vue'\r\nimport { nanoid } from 'nanoid'\r\nimport type { AttachmentFile, UploadHandler } from '../types'\r\n\r\n/**\r\n * Options for the file upload hook\r\n */\r\nexport interface UseFileUploadOptions {\r\n  /** Custom upload handler function */\r\n  handler?: UploadHandler\r\n  /** Max file size in bytes */\r\n  maxSize?: number\r\n  /** Max number of files allowed */\r\n  maxFiles?: number\r\n  /** Accepted file types string */\r\n  accept?: string\r\n}\r\n\r\n/**\r\n * Hook to manage file uploads and attachment state.\r\n * Handles adding files, processing uploads via handler, and tracking progress.\r\n * \r\n * @param {UseFileUploadOptions} options - Configuration options\r\n * @returns {Object} File state and management methods\r\n */\r\nexport function useFileUpload(options: UseFileUploadOptions = {}) {\r\n  const files = ref<AttachmentFile[]>([])\r\n\r\n  const isUploading = computed(() => files.value.some((f) => f.status === 'uploading'))\r\n\r\n  /**\r\n   * Process a single file upload\r\n   * @param {AttachmentFile} attachment - The attachment object to process\r\n   */\r\n  const processFile = async (attachment: AttachmentFile) => {\r\n    if (!options.handler || !attachment.file) {\r\n      // If no handler, mark as done immediately (local mode)\r\n      attachment.status = 'done'\r\n      attachment.progress = 100\r\n      return\r\n    }\r\n\r\n    attachment.status = 'uploading'\r\n    attachment.progress = 0\r\n    attachment.error = undefined\r\n\r\n    try {\r\n      const result = await options.handler(attachment.file, (progress) => {\r\n        attachment.progress = progress\r\n      })\r\n      attachment.status = 'done'\r\n      attachment.serverData = result\r\n      attachment.progress = 100\r\n    } catch (err) {\r\n      console.error('Upload failed', err)\r\n      attachment.status = 'error'\r\n      attachment.error = err instanceof Error ? err : new Error('Upload failed')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add new files to the list and start upload\r\n   * @param {File[] | FileList} newFiles - Files to add\r\n   */\r\n  const addFiles = async (newFiles: File[] | FileList) => {\r\n    const fileArray = Array.from(newFiles)\r\n\r\n    // TODO: Add validation logic here (maxSize, accept, maxFiles)\r\n\r\n    const newAttachments: AttachmentFile[] = fileArray.map((file) => ({\r\n      id: nanoid(),\r\n      file,\r\n      name: file.name,\r\n      type: file.type,\r\n      status: 'pending',\r\n      progress: 0,\r\n    }))\r\n\r\n    files.value = [...files.value, ...newAttachments]\r\n\r\n    // Start uploads\r\n    await Promise.all(newAttachments.map(processFile))\r\n  }\r\n\r\n  /**\r\n   * Retry a failed upload\r\n   * @param {string} id - ID of the file to retry\r\n   */\r\n  const retryUpload = (id: string) => {\r\n    const file = files.value.find((f) => f.id === id)\r\n    if (file) {\r\n      processFile(file)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a file from the list\r\n   * @param {string} id - ID of the file to remove\r\n   */\r\n  const removeFile = (id: string) => {\r\n    files.value = files.value.filter((f) => f.id !== id)\r\n  }\r\n\r\n  /**\r\n   * Clear all files\r\n   */\r\n  const clearFiles = () => {\r\n    files.value = []\r\n  }\r\n\r\n  return {\r\n    files,\r\n    isUploading,\r\n    addFiles,\r\n    retryUpload,\r\n    removeFile,\r\n    clearFiles,\r\n  }\r\n}\r\n"
    },
    {
      "path": "ui/ai-input/hooks\\use-voice.ts",
      "type": "registry:component",
      "content": "import { ref, onMounted, onUnmounted } from 'vue'\r\n\r\n/**\r\n * State of the voice recognition\r\n */\r\nexport type VoiceState = 'idle' | 'listening' | 'processing'\r\n\r\n// Basic type definitions for Web Speech API since they might not be in standard lib yet\r\n/**\r\n * Event interface for speech recognition results\r\n */\r\ninterface SpeechRecognitionEvent extends Event {\r\n  results: SpeechRecognitionResultList\r\n  resultIndex: number\r\n  interpretation: any\r\n}\r\n\r\n/**\r\n * Event interface for speech recognition errors\r\n */\r\ninterface SpeechRecognitionErrorEvent extends Event {\r\n  error: string\r\n  message: string\r\n}\r\n\r\n/**\r\n * Web Speech API Recognition interface\r\n */\r\ninterface SpeechRecognition extends EventTarget {\r\n  continuous: boolean\r\n  interimResults: boolean\r\n  lang: string\r\n  start(): void\r\n  stop(): void\r\n  abort(): void\r\n  onstart: (event: Event) => void\r\n  onend: (event: Event) => void\r\n  onresult: (event: SpeechRecognitionEvent) => void\r\n  onerror: (event: SpeechRecognitionErrorEvent) => void\r\n}\r\n\r\ninterface SpeechRecognitionConstructor {\r\n  new (): SpeechRecognition\r\n}\r\n\r\ndeclare global {\r\n  interface Window {\r\n    SpeechRecognition?: SpeechRecognitionConstructor\r\n    webkitSpeechRecognition?: SpeechRecognitionConstructor\r\n  }\r\n}\r\n\r\n/**\r\n * Hook for using the Web Speech API (Speech-to-Text).\r\n * Handles browser support detection, recording state, and transcription results.\r\n * \r\n * @param {function} onResult - Callback fired when text is transcribed\r\n * @returns {Object} Voice control methods and state\r\n */\r\nexport function useVoice(onResult: (text: string) => void) {\r\n  const state = ref<VoiceState>('idle')\r\n  const recognition = ref<SpeechRecognition | null>(null)\r\n  const isSupported = ref(false)\r\n\r\n  onMounted(() => {\r\n    // Check browser support\r\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition\r\n\r\n    if (SpeechRecognition) {\r\n      isSupported.value = true\r\n      const sr = new SpeechRecognition()\r\n      sr.continuous = true\r\n      sr.interimResults = true\r\n      sr.lang = 'en-US'\r\n\r\n      sr.onstart = () => {\r\n        state.value = 'listening'\r\n      }\r\n\r\n      sr.onend = () => {\r\n        state.value = 'idle'\r\n      }\r\n\r\n      sr.onresult = (event: SpeechRecognitionEvent) => {\r\n        let finalTranscript = ''\r\n        for (let i = event.resultIndex; i < event.results.length; i++) {\r\n          const result = event.results[i]\r\n          if (result.isFinal) {\r\n            finalTranscript += result[0]?.transcript ?? ''\r\n          }\r\n        }\r\n\r\n        if (finalTranscript) {\r\n          onResult(finalTranscript)\r\n        }\r\n      }\r\n\r\n      sr.onerror = (event: SpeechRecognitionErrorEvent) => {\r\n        console.error('Speech recognition error:', event.error)\r\n        state.value = 'idle'\r\n      }\r\n\r\n      recognition.value = sr\r\n    }\r\n  })\r\n\r\n  onUnmounted(() => {\r\n    if (recognition.value && state.value === 'listening') {\r\n      recognition.value.stop()\r\n    }\r\n  })\r\n\r\n  /**\r\n   * Start listening\r\n   */\r\n  const start = () => {\r\n    if (!isSupported.value || state.value === 'listening') return\r\n    try {\r\n      recognition.value?.start()\r\n    } catch (e) {\r\n      console.error('Failed to start speech recognition', e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop listening\r\n   */\r\n  const stop = () => {\r\n    if (state.value !== 'listening') return\r\n    recognition.value?.stop()\r\n  }\r\n\r\n  /**\r\n   * Toggle listening state\r\n   */\r\n  const toggle = () => {\r\n    if (state.value === 'listening') {\r\n      stop()\r\n    } else {\r\n      start()\r\n    }\r\n  }\r\n\r\n  return {\r\n    state,\r\n    isSupported,\r\n    start,\r\n    stop,\r\n    toggle,\r\n  }\r\n}\r\n"
    },
    {
      "path": "ui/ai-input/index.ts",
      "type": "registry:component",
      "content": "/**\r\n * AI Input Library\r\n * \r\n * A Notion-style AI input component with drag & drop, slash commands, and mentions.\r\n * \r\n * @module ai-input\r\n */\r\n\r\n// Components\r\nexport { default as AIInput } from './components/AIInput.vue'\r\nexport { default as AIInputEditor } from './components/AIInputEditor.vue'\r\nexport { default as AIInputToolbar } from './components/AIInputToolbar.vue'\r\nexport { default as AIInputVoice } from './components/AIInputVoice.vue'\r\nexport { default as AIInputAttachButton } from './components/AIInputAttachButton.vue'\r\n\r\n// Core Context & Types\r\nexport * from './core/context'\r\nexport * from './core/types'\r\n\r\n// Extensions\r\nexport { default as ContextItemView } from './extensions/context-item/ContextItemView.vue'\r\nexport { ContextItem } from './extensions/context-item'\r\nexport { FileHandler } from './extensions/file-handler'\r\nexport { HistoryNavigation } from './extensions/history'\r\n\r\n// Hooks\r\nexport { useVoice } from './hooks/use-voice'\r\n"
    },
    {
      "path": "ui/ai-input/types\\index.ts",
      "type": "registry:component",
      "content": "/**\r\n * Global type definitions for the AI Input package.\r\n * Aggregates types from core, registry, and extensions.\r\n */\r\n\r\n// Core types\r\nexport * from '../core/types'\r\n\r\n// Registry types\r\nexport * from '../extensions/context-item/registry/types'\r\n\r\n// Extension types\r\nexport * from '../extensions/slash-command/types'\r\n"
    },
    {
      "path": "ui/ai-input/__tests__\\components.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect, vi } from 'vitest'\r\nimport { mount } from '@vue/test-utils'\r\nimport AIInput from '../components/AIInput.vue'\r\n\r\n// Mock dependencies\r\nvi.mock('@/lib/utils', () => ({\r\n  cn: (...args: any[]) => args.join(' '),\r\n}))\r\n\r\ndescribe('AIInput', () => {\r\n  it('should render correctly', () => {\r\n    const wrapper = mount(AIInput)\r\n    expect(wrapper.find('div').exists()).toBe(true)\r\n    expect(wrapper.find('input[type=\"file\"]').exists()).toBe(true)\r\n  })\r\n\r\n  it('should provide context', () => {\r\n    const wrapper = mount(AIInput)\r\n    // Check if provider is called (implicit via successful mount as useAIInputProvider is called in setup)\r\n    // To truly check injection, we would need a child component test helper\r\n    expect(wrapper.exists()).toBe(true)\r\n  })\r\n\r\n  it('should handle file selection via input', async () => {\r\n    const wrapper = mount(AIInput)\r\n    const input = wrapper.find('input[type=\"file\"]')\r\n\r\n    // Create a mock file\r\n    const file = new File(['content'], 'test.txt', { type: 'text/plain' })\r\n\r\n    // Simulate file selection\r\n    Object.defineProperty(input.element, 'files', {\r\n      value: [file],\r\n    })\r\n\r\n    await input.trigger('change')\r\n  })\r\n\r\n  it('should handle file drop', async () => {\r\n    const wrapper = mount(AIInput)\r\n    const div = wrapper.find('div[data-ai-input]')\r\n\r\n    const file = new File(['content'], 'test.txt', { type: 'text/plain' })\r\n    const mockDataTransfer = {\r\n      types: ['Files'],\r\n      files: [file],\r\n      preventDefault: vi.fn(),\r\n    }\r\n\r\n    await div.trigger('drop', {\r\n      dataTransfer: mockDataTransfer,\r\n    })\r\n\r\n    // Again, we can't easily assert the internal state without mocking useAIInputProvider.\r\n    // But we ensure no error is thrown and the event handler is attached.\r\n    expect(wrapper.exists()).toBe(true)\r\n  })\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/__tests__\\editor.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect, vi } from 'vitest'\r\nimport { useEditorState } from '../hooks/use-editor-state'\r\n\r\n// Mock Vue's onBeforeUnmount to avoid warning in tests\r\nvi.mock('vue', async (importOriginal) => {\r\n  const actual: any = await importOriginal()\r\n  return {\r\n    ...actual,\r\n    onBeforeUnmount: vi.fn(),\r\n  }\r\n})\r\n\r\n// Mock Tiptap\r\nvi.mock('@tiptap/vue-3', () => ({\r\n  useEditor: () => {\r\n    return {\r\n      value: {\r\n        destroy: vi.fn(),\r\n        commands: {\r\n          setContent: vi.fn(),\r\n          focus: vi.fn(),\r\n          clearContent: vi.fn(),\r\n        },\r\n        getHTML: vi.fn(() => '<p>test</p>'),\r\n        isEmpty: false,\r\n        chain: () => ({\r\n          focus: () => ({\r\n            insertContentAt: () => ({\r\n              run: vi.fn(),\r\n            }),\r\n            deleteRange: () => ({\r\n              run: vi.fn(),\r\n            }),\r\n            insertContent: () => ({\r\n              run: vi.fn(),\r\n            }),\r\n          }),\r\n        }),\r\n      },\r\n    }\r\n  },\r\n  Extension: {\r\n    create: (config: any) => config,\r\n  },\r\n  VueRenderer: vi.fn(),\r\n  nodeViewProps: {},\r\n}))\r\n\r\ndescribe('useEditorState', () => {\r\n  it('should initialize editor', () => {\r\n    const { editor } = useEditorState()\r\n    expect(editor.value).toBeDefined()\r\n  })\r\n\r\n  it('should handle history navigation', async () => {\r\n    const history = ['Command 1', 'Command 2']\r\n    const { editor } = useEditorState({ history })\r\n\r\n    // We can't easily trigger the keyboard events directly on the mock,\r\n    // but we can verify the configuration logic if we exported the internal state/handlers.\r\n    // Since we don't, we are limited to checking if editor is created with extensions.\r\n    expect(editor.value).toBeDefined()\r\n  })\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/__tests__\\extensions.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect } from 'vitest'\r\nimport { SlashCommand } from '../extensions/slash-command'\r\nimport { defaultShortcuts } from '../extensions/slash-command/shortcuts'\r\nimport { FileHandler } from '../extensions/file-handler'\r\n\r\ndescribe('SlashCommand', () => {\r\n  it('should have correct default options', () => {\r\n    expect(SlashCommand.options).toBeDefined()\r\n    // Tiptap extension options are usually functions or objects\r\n    // We can't easily check default values without instantiating or checking addOptions\r\n    // But we can check if it exports the right name\r\n    expect(SlashCommand.name).toBe('slashCommand')\r\n  })\r\n\r\n  it('should filter shortcuts correctly', () => {\r\n    // Simulate the filtering logic used in the suggestion items\r\n    const query = 'bug'\r\n    const filtered = defaultShortcuts.filter(\r\n      (item) =>\r\n        item.label.toLowerCase().includes(query.toLowerCase()) ||\r\n        item.key.toLowerCase().includes(query.toLowerCase()),\r\n    )\r\n\r\n    expect(filtered.length).toBeGreaterThan(0)\r\n    expect(filtered[0].label.toLowerCase()).toContain('bug')\r\n  })\r\n})\r\n\r\ndescribe('FileHandler', () => {\r\n  it('should be configurable', () => {\r\n    const configured = FileHandler.configure({\r\n      onDrop: (files) => console.log(files),\r\n    })\r\n\r\n    expect(configured.name).toBe('fileHandler')\r\n  })\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/__tests__\\hooks.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect } from 'vitest'\r\nimport { useFileUpload } from '../hooks/use-file-upload'\r\n\r\ndescribe('useFileUpload', () => {\r\n  it('should initialize with empty files', () => {\r\n    const { files, isUploading } = useFileUpload()\r\n    expect(files.value).toHaveLength(0)\r\n    expect(isUploading.value).toBe(false)\r\n  })\r\n\r\n  it('should add files correctly', async () => {\r\n    const { addFiles, files } = useFileUpload()\r\n    const mockFile = new File([''], 'test.png', { type: 'image/png' })\r\n\r\n    await addFiles([mockFile])\r\n\r\n    expect(files.value).toHaveLength(1)\r\n    expect(files.value[0].name).toBe('test.png')\r\n    expect(files.value[0].status).toBe('done') // No handler provided -> done immediately\r\n    expect(files.value[0].progress).toBe(100)\r\n  })\r\n\r\n  it('should handle upload process with handler', async () => {\r\n    const mockHandler = async (file: File, onProgress?: (p: number) => void) => {\r\n      onProgress?.(50)\r\n      return {\r\n        id: 'test-id',\r\n        url: 'http://example.com/test.png',\r\n        name: file.name,\r\n        type: file.type,\r\n      }\r\n    }\r\n\r\n    const { addFiles, files } = useFileUpload({ handler: mockHandler })\r\n    const mockFile = new File([''], 'test.png', { type: 'image/png' })\r\n\r\n    const uploadPromise = addFiles([mockFile])\r\n\r\n    // Immediate check\r\n    expect(files.value[0].status).toBe('uploading')\r\n\r\n    await uploadPromise\r\n\r\n    expect(files.value[0].status).toBe('done')\r\n    expect(files.value[0].serverData).toEqual({\r\n      id: 'test-id',\r\n      url: 'http://example.com/test.png',\r\n      name: 'test.png',\r\n      type: 'image/png',\r\n    })\r\n  })\r\n\r\n  it('should remove file correctly', async () => {\r\n    const { addFiles, removeFile, files } = useFileUpload()\r\n    const mockFile = new File([''], 'test.png', { type: 'image/png' })\r\n\r\n    await addFiles([mockFile])\r\n    expect(files.value).toHaveLength(1)\r\n\r\n    const id = files.value[0].id\r\n    removeFile(id)\r\n\r\n    expect(files.value).toHaveLength(0)\r\n  })\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/__tests__\\registry.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect } from 'vitest'\r\nimport { createContextItemRegistry } from '../extensions/context-item/registry/index'\r\nimport DefaultContextItem from '../extensions/context-item/components/DefaultContextItem.vue'\r\nimport { defineComponent } from 'vue'\r\n\r\ndescribe('ContextItemRegistry', () => {\r\n  it('should register and retrieve components', () => {\r\n    const registry = createContextItemRegistry()\r\n    const TestComponent = defineComponent({\r\n       name: 'TestComponent',\r\n       props: {\r\n         id: { type: String, required: true },\r\n         label: { type: String, required: true },\r\n         type: { type: String, required: true },\r\n         metadata: { type: Object },\r\n         selected: { type: Boolean, required: true },\r\n         deleteNode: { type: Function, required: true },\r\n         updateAttributes: { type: Function, required: true },\r\n       },\r\n       template: '<div>Test</div>',\r\n     })\r\n \r\n     registry.register('test', TestComponent as any)\r\n\r\n    const item = registry.get('test')\r\n    expect(item).toBeDefined()\r\n    expect(item?.component).toStrictEqual(TestComponent)\r\n  })\r\n\r\n  it('should return default component for unknown types', () => {\r\n    const registry = createContextItemRegistry()\r\n    const item = registry.get('unknown-type')\r\n\r\n    expect(item).toBeDefined()\r\n    // It should return the default item wrapper\r\n    expect(item?.component).toStrictEqual(DefaultContextItem)\r\n  })\r\n\r\n  it('should handle getComponent helper', () => {\r\n    const registry = createContextItemRegistry()\r\n    const TestComponent = defineComponent({ name: 'Test' })\r\n\r\n    registry.register('test', { component: TestComponent })\r\n\r\n    const component = registry.getComponent('test')\r\n    expect(component).toStrictEqual(TestComponent)\r\n  })\r\n})\r\n"
    },
    {
      "path": "ui/ai-input/__tests__\\toolbar.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect, vi } from 'vitest'\r\nimport { mount } from '@vue/test-utils'\r\nimport AIInputToolbar from '../components/AIInputToolbar.vue'\r\nimport { AI_INPUT_KEY } from '../core/types'\r\nimport { ref } from 'vue'\r\n\r\n// Mock dependencies\r\nvi.mock('@/lib/utils', () => ({\r\n  cn: (...args: any[]) => args.join(' '),\r\n}))\r\n\r\nvi.mock('@/components/ui/button', () => ({\r\n  Button: {\r\n    name: 'Button',\r\n    template: '<button :disabled=\"disabled\" @click=\"$emit(\\'click\\')\"><slot /></button>',\r\n    props: ['disabled', 'variant', 'size'],\r\n  },\r\n}))\r\n\r\nvi.mock('lucide-vue-next', () => ({\r\n  ArrowUpIcon: { template: '<svg class=\"arrow-up\" />' },\r\n  SquareIcon: { template: '<svg class=\"square\" />' },\r\n  BugIcon: { template: '<svg />' },\r\n  CodeIcon: { template: '<svg />' },\r\n  TextIcon: { template: '<svg />' },\r\n  SmileIcon: { template: '<svg />' },\r\n  CalendarIcon: { template: '<svg />' },\r\n  HashIcon: { template: '<svg />' },\r\n  DatabaseIcon: { template: '<svg />' },\r\n  TestTubeIcon: { template: '<svg />' },\r\n  PaletteIcon: { template: '<svg />' },\r\n  SparklesIcon: { template: '<svg />' },\r\n}))\r\n\r\ndescribe('AIInputToolbar', () => {\r\n  const createWrapper = (contextOverrides = {}) => {\r\n    return mount(AIInputToolbar, {\r\n      global: {\r\n        provide: {\r\n          [AI_INPUT_KEY]: {\r\n            submit: vi.fn(),\r\n            isLoading: ref(false),\r\n            isEmpty: ref(false),\r\n            ...contextOverrides,\r\n          },\r\n        },\r\n      },\r\n    })\r\n  }\r\n\r\n  it('should render submit button', () => {\r\n    const wrapper = createWrapper()\r\n    expect(wrapper.find('button').exists()).toBe(true)\r\n    expect(wrapper.find('.arrow-up').exists()).toBe(true)\r\n  })\r\n\r\n  it('should disable button when empty', () => {\r\n    const wrapper = createWrapper({ isEmpty: ref(true) })\r\n    // Since we mocked Button with a simple template, we need to find it by element or class if name lookup fails,\r\n    // or ensure the mock component has a name.\r\n    // The previous error \"Cannot call props on an empty VueWrapper\" means findComponent({ name: 'Button' }) failed.\r\n    // Let's try finding by the button tag which our mock renders.\r\n    expect(wrapper.find('button').attributes('disabled')).toBeDefined()\r\n    // Or if we want to check the prop passed to the mock:\r\n    // We need to ensure the mock is registered/found correctly.\r\n    // Since we imported Button from '@/components/ui/button', let's check how we mocked it.\r\n  })\r\n\r\n  it('should show loading state', () => {\r\n    const wrapper = createWrapper({ isLoading: ref(true) })\r\n    expect(wrapper.find('.square').exists()).toBe(true)\r\n    expect(wrapper.find('.arrow-up').exists()).toBe(false)\r\n  })\r\n\r\n  it('should call submit on click', async () => {\r\n    const submit = vi.fn()\r\n    const wrapper = createWrapper({ submit })\r\n\r\n    await wrapper.find('button').trigger('click')\r\n    expect(submit).toHaveBeenCalled()\r\n  })\r\n})\r\n"
    }
  ]
}