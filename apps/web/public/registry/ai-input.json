{
  "name": "ai-input",
  "type": "registry:component",
  "title": "AI Input",
  "description": "A Notion-style AI input with drag & drop, slash commands, and mentions.",
  "dependencies": [
    "@tiptap/vue-3",
    "@tiptap/starter-kit",
    "@tiptap/extension-placeholder",
    "@tiptap/extension-mention",
    "lucide-vue-next",
    "tippy.js"
  ],
  "registryDependencies": [
    "button",
    "badge",
    "card",
    "separator"
  ],
  "files": [
    {
      "path": "ui/ai-input/__tests__/components.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect, vi } from 'vitest'\nimport { mount } from '@vue/test-utils'\nimport AIInput from '../components/AIInput.vue'\nimport { AI_INPUT_KEY } from '../core/types'\n\n// Mock dependencies\nvi.mock('@/lib/utils', () => ({\n  cn: (...args: any[]) => args.join(' ')\n}))\n\ndescribe('AIInput', () => {\n  it('should render correctly', () => {\n    const wrapper = mount(AIInput)\n    expect(wrapper.find('div').exists()).toBe(true)\n    expect(wrapper.find('input[type=\"file\"]').exists()).toBe(true)\n  })\n\n  it('should provide context', () => {\n    const wrapper = mount(AIInput)\n    // Check if provider is called (implicit via successful mount as useAIInputProvider is called in setup)\n    // To truly check injection, we would need a child component test helper\n    expect(wrapper.exists()).toBe(true)\n  })\n\n  it('should handle file selection via input', async () => {\n    const wrapper = mount(AIInput)\n    const input = wrapper.find('input[type=\"file\"]')\n    \n    // Create a mock file\n    const file = new File(['content'], 'test.txt', { type: 'text/plain' })\n    \n    // Simulate file selection\n    Object.defineProperty(input.element, 'files', {\n      value: [file]\n    })\n    \n    await input.trigger('change')\n    \n    // Since we can't easily access the internal state of useAIInputProvider from outside without exporting it or using a spy,\n    // we assume if no error occurred, it handled it. \n    // Ideally we would mock useAIInputProvider but it's part of the component logic being tested.\n  })\n})\n"
    },
    {
      "path": "ui/ai-input/__tests__/editor.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { useEditorState } from '../hooks/use-editor-state'\nimport { nextTick } from 'vue'\n\n// Mock Tiptap\nvi.mock('@tiptap/vue-3', () => ({\n  useEditor: (options: any) => {\n    return {\n      value: {\n        destroy: vi.fn(),\n        commands: {\n          setContent: vi.fn(),\n          focus: vi.fn(),\n          clearContent: vi.fn()\n        },\n        getHTML: vi.fn(() => '<p>test</p>'),\n        isEmpty: false,\n        chain: () => ({\n          focus: () => ({\n            insertContentAt: () => ({\n              run: vi.fn()\n            }),\n            deleteRange: () => ({\n              run: vi.fn()\n            }),\n            insertContent: () => ({\n              run: vi.fn()\n            })\n          })\n        })\n      }\n    }\n  },\n  Extension: {\n    create: (config: any) => config\n  },\n  VueRenderer: vi.fn(),\n  nodeViewProps: {}\n}))\n\ndescribe('useEditorState', () => {\n  it('should initialize editor', () => {\n    const { editor } = useEditorState()\n    expect(editor.value).toBeDefined()\n  })\n\n  it('should handle history navigation', async () => {\n    const history = ['Command 1', 'Command 2']\n    const { editor } = useEditorState({ history })\n    \n    // We can't easily trigger the keyboard events directly on the mock,\n    // but we can verify the configuration logic if we exported the internal state/handlers.\n    // Since we don't, we are limited to checking if editor is created with extensions.\n    expect(editor.value).toBeDefined()\n  })\n})\n"
    },
    {
      "path": "ui/ai-input/__tests__/hooks.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect } from 'vitest'\nimport { useFileUpload } from '../hooks/use-file-upload'\n\ndescribe('useFileUpload', () => {\n  it('should initialize with empty files', () => {\n    const { files, isUploading } = useFileUpload()\n    expect(files.value).toHaveLength(0)\n    expect(isUploading.value).toBe(false)\n  })\n\n  it('should add files correctly', async () => {\n    const { addFiles, files } = useFileUpload()\n    const mockFile = new File([''], 'test.png', { type: 'image/png' })\n    \n    await addFiles([mockFile])\n    \n    expect(files.value).toHaveLength(1)\n    expect(files.value[0].name).toBe('test.png')\n    expect(files.value[0].status).toBe('done') // No handler provided -> done immediately\n    expect(files.value[0].progress).toBe(100)\n  })\n\n  it('should handle upload process with handler', async () => {\n    const mockHandler = async (file: File, onProgress?: (p: number) => void) => {\n      onProgress?.(50)\n      return { \n        id: 'test-id',\n        url: 'http://example.com/test.png',\n        name: file.name,\n        type: file.type\n      }\n    }\n    \n    const { addFiles, files } = useFileUpload({ handler: mockHandler })\n    const mockFile = new File([''], 'test.png', { type: 'image/png' })\n    \n    const uploadPromise = addFiles([mockFile])\n    \n    // Immediate check\n    expect(files.value[0].status).toBe('uploading')\n    \n    await uploadPromise\n    \n    expect(files.value[0].status).toBe('done')\n    expect(files.value[0].serverData).toEqual({ \n      id: 'test-id',\n      url: 'http://example.com/test.png',\n      name: 'test.png',\n      type: 'image/png'\n    })\n  })\n\n  it('should remove file correctly', async () => {\n    const { addFiles, removeFile, files } = useFileUpload()\n    const mockFile = new File([''], 'test.png', { type: 'image/png' })\n    \n    await addFiles([mockFile])\n    expect(files.value).toHaveLength(1)\n    \n    const id = files.value[0].id\n    removeFile(id)\n    \n    expect(files.value).toHaveLength(0)\n  })\n})\n"
    },
    {
      "path": "ui/ai-input/__tests__/registry.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect } from 'vitest'\nimport { createContextItemRegistry } from '../extensions/context-item/registry/index'\nimport DefaultContextItem from '../extensions/context-item/components/DefaultContextItem.vue'\nimport { defineComponent, markRaw } from 'vue'\n\ndescribe('ContextItemRegistry', () => {\n  it('should register and retrieve components', () => {\n    const registry = createContextItemRegistry()\n    const TestComponent = defineComponent({ name: 'Test' })\n    \n    registry.register('test', TestComponent)\n    \n    const item = registry.get('test')\n    expect(item).toBeDefined()\n    expect(item?.component).toStrictEqual(TestComponent)\n  })\n\n  it('should return default component for unknown types', () => {\n    const registry = createContextItemRegistry()\n    const item = registry.get('unknown-type')\n    \n    expect(item).toBeDefined()\n    // It should return the default item wrapper\n    expect(item?.component).toStrictEqual(DefaultContextItem)\n  })\n\n  it('should handle getComponent helper', () => {\n    const registry = createContextItemRegistry()\n    const TestComponent = defineComponent({ name: 'Test' })\n    \n    registry.register('test', { component: TestComponent })\n    \n    const component = registry.getComponent('test')\n    expect(component).toStrictEqual(TestComponent)\n  })\n})\n"
    },
    {
      "path": "ui/ai-input/__tests__/toolbar.test.ts",
      "type": "registry:component",
      "content": "import { describe, it, expect, vi } from 'vitest'\nimport { mount } from '@vue/test-utils'\nimport AIInputToolbar from '../components/AIInputToolbar.vue'\nimport { AI_INPUT_KEY } from '../core/types'\nimport { ref } from 'vue'\n\n// Mock dependencies\nvi.mock('@/lib/utils', () => ({\n  cn: (...args: any[]) => args.join(' ')\n}))\n\nvi.mock('@/components/ui/button', () => ({\n  Button: {\n    name: 'Button',\n    template: '<button :disabled=\"disabled\" @click=\"$emit(\\'click\\')\"><slot /></button>',\n    props: ['disabled', 'variant', 'size']\n  }\n}))\n\nvi.mock('lucide-vue-next', () => ({\n  ArrowUpIcon: { template: '<svg class=\"arrow-up\" />' },\n  SquareIcon: { template: '<svg class=\"square\" />' },\n  BugIcon: { template: '<svg />' },\n  CodeIcon: { template: '<svg />' },\n  TextIcon: { template: '<svg />' },\n  SmileIcon: { template: '<svg />' },\n  CalendarIcon: { template: '<svg />' },\n   HashIcon: { template: '<svg />' },\n   DatabaseIcon: { template: '<svg />' },\n   TestTubeIcon: { template: '<svg />' },\n   PaletteIcon: { template: '<svg />' },\n   SparklesIcon: { template: '<svg />' }\n}))\n\ndescribe('AIInputToolbar', () => {\n  const createWrapper = (contextOverrides = {}) => {\n    return mount(AIInputToolbar, {\n      global: {\n        provide: {\n          [AI_INPUT_KEY]: {\n            submit: vi.fn(),\n            isLoading: ref(false),\n            isEmpty: ref(false),\n            ...contextOverrides\n          }\n        }\n      }\n    })\n  }\n\n  it('should render submit button', () => {\n    const wrapper = createWrapper()\n    expect(wrapper.find('button').exists()).toBe(true)\n    expect(wrapper.find('.arrow-up').exists()).toBe(true)\n  })\n\n  it('should disable button when empty', () => {\n    const wrapper = createWrapper({ isEmpty: ref(true) })\n    // Since we mocked Button with a simple template, we need to find it by element or class if name lookup fails,\n    // or ensure the mock component has a name.\n    // The previous error \"Cannot call props on an empty VueWrapper\" means findComponent({ name: 'Button' }) failed.\n    // Let's try finding by the button tag which our mock renders.\n    expect(wrapper.find('button').attributes('disabled')).toBeDefined()\n    // Or if we want to check the prop passed to the mock:\n    // We need to ensure the mock is registered/found correctly. \n    // Since we imported Button from '@/components/ui/button', let's check how we mocked it.\n  })\n\n  it('should show loading state', () => {\n    const wrapper = createWrapper({ isLoading: ref(true) })\n    expect(wrapper.find('.square').exists()).toBe(true)\n    expect(wrapper.find('.arrow-up').exists()).toBe(false)\n  })\n\n  it('should call submit on click', async () => {\n    const submit = vi.fn()\n    const wrapper = createWrapper({ submit })\n    \n    await wrapper.find('button').trigger('click')\n    expect(submit).toHaveBeenCalled()\n  })\n})\n"
    },
    {
      "path": "ui/ai-input/components/AIInput.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { useAIInputProvider, type AIInputProps } from '../context'\nimport AIInputAttachments from './AIInputAttachments.vue'\n\ninterface Props extends AIInputProps {\n  class?: HTMLAttributes['class']\n}\n\nconst props = defineProps<Props>()\n\nconst { fileInputRef, addFiles } = useAIInputProvider(props)\n\nfunction onFileChange(e: Event) {\n  const input = e.target as HTMLInputElement\n  if (input.files) {\n    addFiles(input.files)\n  }\n  input.value = ''\n}\n\nfunction handleDragOver(e: DragEvent) {\n  if (e.dataTransfer?.types?.includes('Files')) {\n    e.preventDefault()\n  }\n}\n\nfunction handleDrop(e: DragEvent) {\n  if (e.dataTransfer?.types?.includes('Files')) {\n    e.preventDefault()\n    \n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      addFiles(e.dataTransfer.files)\n    }\n  }\n}\n</script>\n\n<template>\n  <div\n    data-ai-input\n    :class=\"cn(\n      'relative flex w-full flex-col overflow-hidden rounded-xl border bg-background focus-within:ring-1 focus-within:ring-ring',\n      props.class,\n    )\"\n    @dragover=\"handleDragOver\"\n    @drop=\"handleDrop\"\n  >\n    <input\n      ref=\"fileInputRef\"\n      type=\"file\"\n      class=\"hidden\"\n      multiple\n      @change=\"onFileChange\"\n    >\n    <AIInputAttachments />\n    <slot />\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/components/AIInputAttachButton.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/ui/button'\nimport { PaperclipIcon } from 'lucide-vue-next'\nimport { useAIInputContext } from './context'\n\nconst { fileInputRef } = useAIInputContext()\n\nconst onClick = () => {\n  fileInputRef.value?.click()\n}\n</script>\n\n<template>\n  <Button\n    variant=\"ghost\"\n    size=\"icon\"\n    class=\"h-8 w-8 rounded-full\"\n    @click=\"onClick\"\n  >\n    <PaperclipIcon class=\"h-4 w-4\" />\n  </Button>\n</template>\n"
    },
    {
      "path": "ui/ai-input/components/AIInputAttachments.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { cn } from '@/lib/utils'\nimport { FileIcon, XIcon, RefreshCwIcon, AlertCircleIcon } from 'lucide-vue-next'\nimport { useAIInputContext } from '../context'\nimport { computed } from 'vue'\n\nconst props = defineProps<{\n  class?: string\n}>()\n\nconst { files, removeFile, retryUpload } = useAIInputContext()\n\nconst hasFiles = computed(() => files.value.length > 0)\n</script>\n\n<template>\n  <div\n    v-if=\"hasFiles\"\n    :class=\"cn('flex flex-wrap items-center gap-2 p-3 w-full border-b bg-muted/30', props.class)\"\n  >\n    <div\n      v-for=\"file in files\"\n      :key=\"file.id\"\n      class=\"group relative flex items-center gap-2 rounded-lg border bg-background px-3 py-2 text-sm shadow-sm transition-all hover:shadow-md\"\n    >\n      <!-- Icon based on status -->\n      <div class=\"relative flex h-8 w-8 items-center justify-center rounded bg-muted\">\n        <AlertCircleIcon v-if=\"file.status === 'error'\" class=\"h-4 w-4 text-destructive\" />\n        <FileIcon v-else class=\"h-4 w-4 text-muted-foreground\" />\n        \n        <!-- Progress Overlay -->\n        <div \n          v-if=\"file.status === 'uploading'\"\n          class=\"absolute inset-0 bg-background/50 flex items-center justify-center\"\n        >\n          <div \n            class=\"h-full w-full bg-primary/20 absolute bottom-0 left-0\"\n            :style=\"{ height: `${file.progress}%` }\"\n          />\n        </div>\n      </div>\n\n      <div class=\"flex flex-col max-w-[150px]\">\n        <span class=\"truncate font-medium text-xs\">{{ file.name }}</span>\n        <span class=\"text-[10px] text-muted-foreground flex items-center gap-1\">\n          <template v-if=\"file.status === 'uploading'\">\n            Uploading {{ file.progress }}%\n          </template>\n          <template v-else-if=\"file.status === 'error'\">\n            Failed\n          </template>\n          <template v-else>\n            {{ (file.file?.size ? (file.file.size / 1024).toFixed(1) + ' KB' : '') }}\n          </template>\n        </span>\n      </div>\n\n      <!-- Actions -->\n      <div class=\"flex items-center gap-1\">\n        <button\n          v-if=\"file.status === 'error'\"\n          type=\"button\"\n          class=\"rounded-full p-1 hover:bg-muted text-muted-foreground hover:text-foreground\"\n          @click=\"retryUpload(file.id)\"\n        >\n          <RefreshCwIcon class=\"h-3 w-3\" />\n        </button>\n        \n        <button\n          type=\"button\"\n          class=\"rounded-full p-1 hover:bg-muted text-muted-foreground hover:text-foreground\"\n          @click=\"removeFile(file.id)\"\n        >\n          <XIcon class=\"h-3 w-3\" />\n        </button>\n      </div>\n\n      <!-- Progress Bar (Bottom Line) -->\n      <div \n        v-if=\"file.status === 'uploading'\"\n        class=\"absolute bottom-0 left-0 h-0.5 bg-primary transition-all duration-300\"\n        :style=\"{ width: `${file.progress}%` }\"\n      />\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/components/AIInputEditor.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { EditorContent } from '@tiptap/vue-3'\nimport { watch } from 'vue'\nimport { useAIInputContext } from '../context'\n\nconst { editor, isDisabled } = useAIInputContext()\n\n// Update editable state\nwatch(isDisabled, (val) => {\n  editor.value?.setEditable(!val)\n})\n</script>\n\n<template>\n  <div class=\"relative w-full\">\n    <EditorContent :editor=\"editor\" />\n  </div>\n</template>\n\n<style>\n/* Placeholder styles */\n.ProseMirror p.is-editor-empty:first-child::before {\n  color: hsl(var(--muted-foreground));\n  content: attr(data-placeholder);\n  float: left;\n  height: 0;\n  pointer-events: none;\n}\n</style>\n"
    },
    {
      "path": "ui/ai-input/components/AIInputToolbar.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/ui/button'\nimport { ArrowUpIcon, SquareIcon } from 'lucide-vue-next'\nimport { useAIInputContext } from '../context'\nimport { cn } from '@/lib/utils'\n\nconst { submit, isLoading, isEmpty } = useAIInputContext()\n</script>\n\n<template>\n  <div class=\"flex items-center justify-between p-2\">\n    <div class=\"flex items-center gap-2\">\n      <!-- Left slots (attachments, voice, etc.) -->\n      <slot name=\"left\" />\n    </div>\n    \n    <div class=\"flex items-center gap-2\">\n      <!-- Right slots -->\n      <slot name=\"right\" />\n      \n      <Button\n        size=\"icon\"\n        :variant=\"isLoading ? 'outline' : 'default'\"\n        :disabled=\"isEmpty && !isLoading\"\n        :class=\"cn('h-8 w-8 rounded-full transition-all', isLoading && 'animate-pulse')\"\n        @click=\"submit\"\n      >\n        <SquareIcon v-if=\"isLoading\" class=\"h-4 w-4 fill-current\" />\n        <ArrowUpIcon v-else class=\"h-4 w-4\" />\n      </Button>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/components/AIInputVoice.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/ui/button'\nimport { MicIcon } from 'lucide-vue-next'\nimport { useVoice } from './useVoice'\nimport { useAIInputContext } from './context'\nimport { cn } from '@/lib/utils'\n\nconst { editor } = useAIInputContext()\n\nconst { state, toggle, isSupported } = useVoice((text) => {\n  if (editor.value) {\n    editor.value.chain().focus().insertContent(text + ' ').run()\n  }\n})\n</script>\n\n<template>\n  <Button\n    v-if=\"isSupported\"\n    size=\"icon\"\n    variant=\"ghost\"\n    :class=\"cn('h-8 w-8 rounded-full transition-all', state === 'listening' && 'bg-red-100 text-red-600 hover:bg-red-100 hover:text-red-700 dark:bg-red-900/30 dark:text-red-400')\"\n    @click=\"toggle\"\n  >\n    <MicIcon v-if=\"state !== 'listening'\" class=\"h-4 w-4\" />\n    <div v-else class=\"flex items-center gap-0.5\">\n      <div class=\"h-2 w-0.5 animate-bounce bg-current [animation-delay:-0.3s]\" />\n      <div class=\"h-3 w-0.5 animate-bounce bg-current [animation-delay:-0.15s]\" />\n      <div class=\"h-2 w-0.5 animate-bounce bg-current\" />\n    </div>\n  </Button>\n</template>\n"
    },
    {
      "path": "ui/ai-input/core/context.ts",
      "type": "registry:component",
      "content": "import { inject, provide, ref, computed, watch } from 'vue'\nimport type { Editor } from '@tiptap/vue-3'\nimport { AI_INPUT_KEY, type AIInputContext, type AttachmentFile, type UploadHandler, type UploadResult } from './types'\nimport { createContextItemRegistry } from '../extensions/context-item/registry'\nimport { CONTEXT_ITEM_REGISTRY_KEY } from '../extensions/context-item/registry/types'\nimport { useFileUpload } from '../hooks/use-file-upload'\nimport { useEditorState } from '../hooks/use-editor-state'\n\nexport interface AIInputProps {\n  disabled?: boolean\n  loading?: boolean\n  history?: string[]\n  uploadHandler?: UploadHandler\n  // accept, maxFiles etc. can be added here if needed for global drag validation\n  accept?: string\n  maxSize?: number\n  maxFiles?: number\n  placeholder?: string\n  onSubmit?: (content: string, files: AttachmentFile[]) => void\n}\n\nexport function useAIInputProvider(props: AIInputProps) {\n  const fileInputRef = ref<HTMLInputElement | null>(null)\n  \n  // Use the extracted hook for file management\n  const { \n    files, \n    isUploading: isFileUploading, \n    addFiles, \n    retryUpload, \n    removeFile, \n    clearFiles \n  } = useFileUpload({\n    handler: props.uploadHandler,\n    maxSize: props.maxSize,\n    maxFiles: props.maxFiles,\n    accept: props.accept\n  })\n  \n  const isLoading = computed(() => props.loading ?? false)\n  const isUploading = computed(() => isFileUploading.value)\n  const isDisabled = computed(() => props.disabled || isLoading.value)\n  \n  // Internal submit handler\n  const handleSubmit = () => {\n    if (isDisabled.value || isUploading.value) return\n    \n    if (files.value.some((f: any) => f.status === 'error')) {\n      return \n    }\n\n    // Editor instance comes from the hook now\n    const content = editor.value?.getHTML() || ''\n    if (!content && files.value.length === 0) return\n\n    props.onSubmit?.(content, files.value)\n    \n    editor.value?.commands.clearContent()\n    clearFiles()\n  }\n\n  // Use the extracted hook for editor state\n  const { editor } = useEditorState({\n    history: props.history,\n    placeholder: props.placeholder,\n    onSubmit: handleSubmit,\n    onAddFiles: addFiles\n  })\n\n  const isEmpty = computed(() => editor.value?.isEmpty ?? true)\n  const history = computed(() => props.history || [])\n\n  // Initialize Registry\n  const registry = createContextItemRegistry()\n  provide(CONTEXT_ITEM_REGISTRY_KEY, registry)\n\n  // setEditor is no longer needed to be exposed publicly as we manage it internally,\n  // but we keep it in context if we want to allow external control (though useEditorState handles it).\n  // However, AIInputEditor.vue currently uses useEditor internally. \n  // Wait, AIInputEditor.vue previously CREATED the editor. \n  // Now we moved creation to useEditorState. \n  // So AIInputEditor.vue needs to become a wrapper that just renders <EditorContent :editor=\"editor\" />.\n  \n  const setEditor = (instance: Editor) => {\n    // This might be deprecated if we move full control to useEditorState\n    editor.value = instance\n  }\n\n  const context: AIInputContext = {\n    editor,\n    files,\n    isUploading,\n    isDisabled,\n    isEmpty,\n    history,\n    isLoading,\n    fileInputRef,\n    setEditor,\n    addFiles,\n    retryUpload,\n    removeFile,\n    submit: handleSubmit,\n    focus: () => {\n      editor.value?.commands.focus()\n    }\n  }\n\n  provide(AI_INPUT_KEY, context)\n\n  return context\n}\n\nexport function useAIInputContext() {\n  const context = inject<AIInputContext>(AI_INPUT_KEY)\n  if (!context) {\n    throw new Error('useAIInputContext must be used within AIInput')\n  }\n  return context\n}\n"
    },
    {
      "path": "ui/ai-input/core/types.ts",
      "type": "registry:component",
      "content": "import type { Editor } from '@tiptap/vue-3'\nimport type { Ref } from 'vue'\n\nexport interface UploadResult {\n  id: string\n  url?: string\n  name: string\n  type: string\n  // Extendable for other metadata\n}\n\nexport type UploadHandler = (\n  file: File, \n  onProgress?: (progress: number) => void\n) => Promise<UploadResult>\n\nexport interface AttachmentFile {\n  id: string\n  file?: File\n  type?: string\n  name?: string\n  \n  // Upload status\n  status: 'pending' | 'uploading' | 'done' | 'error'\n  progress: number\n  error?: Error\n  \n  // Server data after upload\n  serverData?: UploadResult\n}\n\nexport interface AIInputContext {\n  editor: Ref<Editor | undefined>\n  files: Ref<AttachmentFile[]>\n  isLoading: Ref<boolean>\n  isDisabled: Ref<boolean>\n  fileInputRef: Ref<HTMLInputElement | null>\n  \n  // Actions\n  setEditor: (instance: Editor) => void\n  addFiles: (files: File[] | FileList) => Promise<void>\n  removeFile: (id: string) => void\n  submit: () => void\n  focus: () => void\n  retryUpload: (id: string) => void\n  \n  // Helpers\n  isEmpty: Ref<boolean>\n  history: Ref<string[]>\n  isUploading: Ref<boolean>\n}\n\nexport const AI_INPUT_KEY = Symbol('AIInputContext')\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/ContextItemView.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { NodeViewWrapper, nodeViewProps } from '@tiptap/vue-3'\nimport { computed, inject } from 'vue'\nimport { CONTEXT_ITEM_REGISTRY_KEY } from './registry/types'\n\nconst props = defineProps(nodeViewProps)\n\nconst registry = inject(CONTEXT_ITEM_REGISTRY_KEY) as any\nconst type = computed(() => props.node.attrs.type)\n\n// Fallback safely if registry is missing (e.g. usage outside of AIInputProvider)\nconst TargetComponent = computed(() => {\n  if (!registry) return null\n  return registry.getComponent(type.value)\n})\n</script>\n\n<template>\n  <NodeViewWrapper as=\"span\" class=\"inline-block align-middle mx-1 select-none\">\n    <component \n      v-if=\"TargetComponent\"\n      :is=\"TargetComponent\"\n      :id=\"node.attrs.id\"\n      :type=\"type\"\n      :label=\"node.attrs.label\"\n      :metadata=\"node.attrs.metadata\"\n      :selected=\"selected\"\n      :delete-node=\"deleteNode\"\n      :update-attributes=\"updateAttributes\"\n    />\n    <span v-else class=\"text-destructive text-xs border border-destructive px-1 rounded\">[Unknown: {{ type }}]</span>\n  </NodeViewWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/components/ContextItemWrapper.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { cn } from '@/lib/utils'\nimport { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover'\nimport { Button } from '@/components/ui/button'\nimport { TrashIcon, ExternalLinkIcon, GripVerticalIcon } from 'lucide-vue-next'\nimport type { Component } from 'vue'\n\nconst props = defineProps<{\n  id: string\n  label: string\n  icon?: Component\n  type?: string\n  metadata?: Record<string, any>\n  selected?: boolean\n  closable?: boolean\n  \n  // Actions\n  onRemove?: () => void\n  onOpen?: () => void\n}>()\n</script>\n\n<template>\n  <Popover>\n    <PopoverTrigger as-child>\n      <span\n        :class=\"cn(\n          'inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-xs font-medium transition-colors cursor-pointer select-none',\n          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',\n          props.selected && 'ring-2 ring-ring'\n        )\"\n      >\n        <component :is=\"icon\" v-if=\"icon\" class=\"h-3 w-3 opacity-70\" />\n        \n        <!-- Main Label Slot or Default -->\n        <slot name=\"trigger\">\n          <span class=\"max-w-[150px] truncate\">{{ label }}</span>\n        </slot>\n\n        <!-- Quick Remove Button (visible on hover or always) -->\n        <button\n          v-if=\"onRemove\"\n          @click.stop=\"onRemove\"\n          class=\"ml-1 rounded-full p-0.5 hover:bg-muted-foreground/20 focus:outline-none opacity-50 hover:opacity-100\"\n          contenteditable=\"false\"\n          type=\"button\"\n        >\n          <TrashIcon class=\"h-3 w-3\" />\n        </button>\n      </span>\n    </PopoverTrigger>\n    \n    <PopoverContent class=\"w-72 p-0\" align=\"start\">\n      <!-- Header -->\n      <div class=\"flex items-center justify-between border-b px-3 py-2 bg-muted/30\">\n        <div class=\"flex items-center gap-2\">\n          <component :is=\"icon\" v-if=\"icon\" class=\"h-3 w-3 text-muted-foreground\" />\n          <span class=\"font-medium text-xs\">{{ type || 'Item' }}</span>\n        </div>\n        <div class=\"flex items-center gap-1\">\n           <Button \n            v-if=\"onRemove\"\n            variant=\"ghost\" \n            size=\"icon\" \n            class=\"h-6 w-6 text-muted-foreground hover:text-destructive\"\n            @click=\"onRemove\"\n          >\n            <TrashIcon class=\"h-3 w-3\" />\n          </Button>\n        </div>\n      </div>\n\n      <!-- Body -->\n      <div class=\"p-3\">\n        <slot />\n      </div>\n\n      <!-- Footer (Metadata Debug or Extra Actions) -->\n      <div v-if=\"metadata?.url || id\" class=\"border-t px-3 py-1.5 bg-muted/10 text-[10px] text-muted-foreground flex justify-between items-center\">\n        <span class=\"font-mono opacity-50\">ID: {{ id.slice(0, 6) }}...</span>\n        <a \n          v-if=\"metadata?.url\"\n          :href=\"metadata.url\"\n          target=\"_blank\"\n          class=\"flex items-center gap-1 hover:underline hover:text-primary\"\n        >\n          Open Link <ExternalLinkIcon class=\"h-3 w-3\" />\n        </a>\n      </div>\n    </PopoverContent>\n  </Popover>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/components/DefaultContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { FileIcon, HashIcon } from 'lucide-vue-next'\nimport { computed } from 'vue'\nimport type { ContextItemProps } from '../registry/types'\nimport ContextItemWrapper from './ContextItemWrapper.vue'\n\nconst props = defineProps<ContextItemProps>()\n\nconst icon = computed(() => {\n  if (props.type === 'variable') return HashIcon\n  return FileIcon\n})\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"label\"\n    :type=\"type\"\n    :icon=\"icon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <!-- Default content just shows basic info -->\n    <div class=\"space-y-2 text-sm\">\n      <div class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\n        <span class=\"text-muted-foreground\">Label</span>\n        <span class=\"font-medium truncate\">{{ label }}</span>\n      </div>\n      <div v-if=\"metadata?.size\" class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\n        <span class=\"text-muted-foreground\">Size</span>\n        <span>{{ (metadata.size / 1024).toFixed(1) }} KB</span>\n      </div>\n      <div v-if=\"metadata?.mimeType\" class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\n        <span class=\"text-muted-foreground\">Type</span>\n        <span class=\"font-mono text-xs\">{{ metadata.mimeType }}</span>\n      </div>\n    </div>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/components/items/DateContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { CalendarIcon } from 'lucide-vue-next'\nimport { computed } from 'vue'\nimport type { ContextItemProps } from '../../registry/types'\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\nimport { Calendar } from '@/components/ui/calendar'\nimport { format } from 'date-fns'\n\nconst props = defineProps<ContextItemProps>()\n\n// Metadata structure: { date: string (ISO) }\nconst currentDate = computed(() => {\n  return props.metadata?.date ? new Date(props.metadata.date) : undefined\n})\n\nconst displayLabel = computed(() => {\n  const dateStr = currentDate.value ? format(currentDate.value, 'yyyy-MM-dd') : 'Pick a date'\n  return `${props.label}: ${dateStr}`\n})\n\nconst handleSelect = (date: Date | undefined) => {\n  if (!date) return\n  props.updateAttributes({\n    metadata: {\n      ...props.metadata,\n      date: date.toISOString()\n    }\n  })\n}\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"displayLabel\"\n    :type=\"type\"\n    :icon=\"CalendarIcon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <div class=\"p-2\">\n      <Calendar\n        mode=\"single\"\n        :model-value=\"currentDate\"\n        @update:model-value=\"handleSelect\"\n        class=\"rounded-md border\"\n      />\n    </div>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/components/items/NumberContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { RulerIcon } from 'lucide-vue-next'\nimport { computed, ref, watch } from 'vue'\nimport type { ContextItemProps } from '../../registry/types'\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\nimport { Input } from '@/components/ui/input'\nimport { Label } from '@/components/ui/label'\nimport { Slider } from '@/components/ui/slider'\n\nconst props = defineProps<ContextItemProps>()\n\n// Metadata structure: { value: number, unit: string, min?: number, max?: number, step?: number }\nconst unit = computed(() => props.metadata?.unit || '')\nconst min = computed(() => props.metadata?.min ?? 0)\nconst max = computed(() => props.metadata?.max ?? 100)\nconst step = computed(() => props.metadata?.step ?? 1)\n\n// Local state for editing\nconst currentValue = ref(props.metadata?.value ?? 0)\n\n// Sync from props\nwatch(() => props.metadata?.value, (val) => {\n  if (val !== undefined) currentValue.value = val\n}, { immediate: true })\n\n// Sync to props\nconst updateValue = (val: number) => {\n  currentValue.value = val\n  props.updateAttributes({\n    metadata: {\n      ...props.metadata,\n      value: val\n    }\n  })\n}\n\nconst displayLabel = computed(() => {\n  return `${props.label}: ${currentValue.value}${unit.value ? ' ' + unit.value : ''}`\n})\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"displayLabel\"\n    :type=\"type\"\n    :icon=\"RulerIcon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <div class=\"space-y-4 py-2\">\n      <div class=\"space-y-1\">\n        <Label class=\"text-xs\">{{ label }} ({{ unit }})</Label>\n        <div class=\"flex items-center gap-2\">\n          <Input \n            type=\"number\" \n            :model-value=\"currentValue\"\n            @update:model-value=\"(v) => updateValue(Number(v))\"\n            :min=\"min\"\n            :max=\"max\"\n            :step=\"step\"\n            class=\"h-8\"\n          />\n        </div>\n      </div>\n      \n      <Slider\n        :model-value=\"[currentValue]\"\n        :min=\"min\"\n        :max=\"max\"\n        :step=\"step\"\n        @update:model-value=\"(v) => updateValue(v[0])\"\n      />\n    </div>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/components/items/SelectContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { ListIcon, CheckIcon } from 'lucide-vue-next'\nimport { computed } from 'vue'\nimport type { ContextItemProps } from '../../registry/types'\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\nimport { Command, CommandInput, CommandList, CommandItem, CommandEmpty, CommandGroup } from '@/components/ui/command'\nimport { cn } from '@/lib/utils'\n\nconst props = defineProps<ContextItemProps>()\n\n// Metadata structure: { value: string, options: { label: string, value: string }[] }\nconst options = computed(() => props.metadata?.options || [])\nconst currentValue = computed(() => props.metadata?.value)\n\nconst selectedOption = computed(() => \n  options.value.find((opt: any) => opt.value === currentValue.value)\n)\n\nconst displayLabel = computed(() => {\n  return `${props.label}: ${selectedOption.value?.label || currentValue.value || 'Select...'}`\n})\n\nconst handleSelect = (val: string) => {\n  props.updateAttributes({\n    metadata: {\n      ...props.metadata,\n      value: val\n    }\n  })\n}\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"displayLabel\"\n    :type=\"type\"\n    :icon=\"ListIcon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <Command class=\"w-full\">\n      <CommandInput placeholder=\"Search options...\" class=\"h-8\" />\n      <CommandList>\n        <CommandEmpty>No option found.</CommandEmpty>\n        <CommandGroup>\n          <CommandItem\n            v-for=\"option in options\"\n            :key=\"option.value\"\n            :value=\"option.value\"\n            @select=\"handleSelect(option.value)\"\n          >\n            <CheckIcon\n              :class=\"cn(\n                'mr-2 h-4 w-4',\n                currentValue === option.value ? 'opacity-100' : 'opacity-0'\n              )\"\n            />\n            {{ option.label }}\n          </CommandItem>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/index.ts",
      "type": "registry:component",
      "content": "import { Node, mergeAttributes } from '@tiptap/core'\nimport { VueNodeViewRenderer } from '@tiptap/vue-3'\nimport ContextItemView from './ContextItemView.vue'\n\nexport const ContextItem = Node.create({\n  name: 'contextItem',\n  group: 'inline',\n  inline: true,\n  atom: true,\n\n  addAttributes() {\n    return {\n      id: {\n        default: null,\n      },\n      type: {\n        default: 'file',\n      },\n      label: {\n        default: 'Context Item',\n      },\n      metadata: {\n        default: {},\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'context-item',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['context-item', mergeAttributes(HTMLAttributes)]\n  },\n\n  addNodeView() {\n    return VueNodeViewRenderer(ContextItemView)\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/registry/index.ts",
      "type": "registry:component",
      "content": "import { reactive, defineAsyncComponent } from 'vue'\nimport type { ContextItemRegistry, ContextItemComponent, RegistryItem } from './types'\nimport DefaultContextItem from '../components/DefaultContextItem.vue'\nimport NumberContextItem from '../components/items/NumberContextItem.vue'\nimport SelectContextItem from '../components/items/SelectContextItem.vue'\nimport DateContextItem from '../components/items/DateContextItem.vue'\n\nexport function createContextItemRegistry(): ContextItemRegistry {\n  const items = reactive<Record<string, RegistryItem>>({\n    'default': { component: DefaultContextItem },\n    'number': { component: NumberContextItem },\n    'select': { component: SelectContextItem },\n    'date': { component: DateContextItem }\n  })\n\n  const register = (type: string, item: ContextItemComponent | RegistryItem) => {\n    if ('component' in (item as any)) {\n      items[type] = item as RegistryItem\n    } else {\n      items[type] = { component: item as ContextItemComponent }\n    }\n  }\n\n  const get = (type: string) => {\n    return items[type] || items['default']\n  }\n  \n  const getComponent = (type: string) => {\n    const item = get(type)\n    if (!item) return undefined\n    \n    // Check if it's an async component loader (function)\n    if (typeof item.component === 'function' && !('render' in item.component)) {\n       return defineAsyncComponent(item.component as any)\n    }\n    \n    return item.component\n  }\n\n  return {\n    register,\n    get,\n    getComponent\n  }\n}\n"
    },
    {
      "path": "ui/ai-input/extensions/context-item/registry/types.ts",
      "type": "registry:component",
      "content": "import type { Component, AsyncComponentLoader } from 'vue'\n\nexport interface ContextItemProps {\n  // Tiptap node attributes\n  id: string\n  label: string\n  type: string\n  metadata?: Record<string, any>\n  \n  // Interaction state\n  selected: boolean\n  \n  // Actions\n  deleteNode: () => void\n  updateAttributes: (attrs: Record<string, any>) => void\n}\n\nexport type ContextItemComponent = Component<ContextItemProps>\n\nexport interface RegistryItem {\n  component: ContextItemComponent | AsyncComponentLoader\n  meta?: {\n    label?: string\n    icon?: Component\n  }\n}\n\nexport interface ContextItemRegistry {\n  register: (type: string, item: ContextItemComponent | RegistryItem) => void\n  get: (type: string) => RegistryItem | undefined\n  getComponent: (type: string) => ContextItemComponent | AsyncComponentLoader | undefined\n}\n\nexport const CONTEXT_ITEM_REGISTRY_KEY = Symbol('ContextItemRegistry')\n"
    },
    {
      "path": "ui/ai-input/extensions/file-handler/index.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nexport interface FileHandlerOptions {\n  onDrop?: (files: File[], pos: number) => void\n  onPaste?: (files: File[]) => void\n  onReferenceDrop?: (data: any, pos: number) => void\n}\n\nexport const FileHandler = Extension.create<FileHandlerOptions>({\n  name: 'fileHandler',\n\n  addOptions() {\n    return {\n      onDrop: undefined,\n      onPaste: undefined,\n      onReferenceDrop: undefined,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('fileHandler'),\n        props: {\n          handleDrop: (view, event, _slice, moved) => {\n            if (moved) return false\n\n            const dataTransfer = event.dataTransfer\n            if (!dataTransfer) return false\n\n            // 1. Check for Internal Reference Drop (Custom MIME type)\n            // We use 'application/x-ai-ref' to identify our own draggable items\n            const refData = dataTransfer.getData('application/x-ai-ref')\n            if (refData) {\n              event.preventDefault()\n              try {\n                const parsed = JSON.parse(refData)\n                const coords = { left: event.clientX, top: event.clientY }\n                const pos = view.posAtCoords(coords)?.pos || view.state.selection.from\n                \n                if (this.options.onReferenceDrop) {\n                  this.options.onReferenceDrop(parsed, pos)\n                }\n                return true\n              } catch (e) {\n                console.error('Failed to parse reference drop data', e)\n              }\n            }\n\n            // 2. Check for Files\n            const hasFiles = dataTransfer.files?.length\n            if (hasFiles) {\n              event.preventDefault()\n              const files = Array.from(dataTransfer.files)\n              const coords = { left: event.clientX, top: event.clientY }\n              const pos = view.posAtCoords(coords)?.pos || view.state.selection.from\n              \n              if (this.options.onDrop) {\n                this.options.onDrop(files, pos)\n              }\n              return true\n            }\n\n            return false\n          },\n          handlePaste: (view, event) => {\n             const items = event.clipboardData?.items\n             if (!items) return false\n             \n             const files: File[] = []\n             for (const item of Array.from(items)) {\n               if (item.kind === 'file') {\n                 const file = item.getAsFile()\n                 if (file) files.push(file)\n               }\n             }\n             \n             if (files.length > 0) {\n                event.preventDefault()\n                if (this.options.onPaste) {\n                    this.options.onPaste(files)\n                }\n                return true\n             }\n             return false\n          }\n        },\n      }),\n    ]\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/history/index.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\n\nexport interface HistoryNavigationOptions {\n  onUp?: () => boolean\n  onDown?: () => boolean\n}\n\nexport const HistoryNavigation = Extension.create<HistoryNavigationOptions>({\n  name: 'historyNavigation',\n\n  addOptions() {\n    return {\n      onUp: undefined,\n      onDown: undefined,\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      ArrowUp: () => {\n        // Trigger if editor is empty or cursor is at start\n        const { selection, doc } = this.editor.state\n        const isAtStart = selection.$anchor.pos === 1\n        const isEmpty = this.editor.isEmpty\n\n        if ((isEmpty || isAtStart) && this.options.onUp) {\n          return this.options.onUp()\n        }\n        return false\n      },\n      ArrowDown: () => {\n        // Trigger if editor is empty or cursor is at end\n        const { selection, doc } = this.editor.state\n        const isAtEnd = selection.$anchor.pos === doc.content.size - 1\n        const isEmpty = this.editor.isEmpty\n\n        if ((isEmpty || isAtEnd) && this.options.onDown) {\n          return this.options.onDown()\n        }\n        return false\n      },\n    }\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/mention/MentionList.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { ref, watch } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { FileIcon } from 'lucide-vue-next'\n\ninterface Item {\n  id: string\n  label: string\n}\n\ninterface Props {\n  items: Item[]\n  command: (props: any) => void\n}\n\nconst props = defineProps<Props>()\n\nconst selectedIndex = ref(0)\n\nwatch(() => props.items, () => {\n  selectedIndex.value = 0\n})\n\nconst selectItem = (index: number) => {\n  const item = props.items[index]\n  if (item) {\n    props.command({ id: item.id, label: item.label })\n  }\n}\n\nconst onKeyDown = ({ event }: { event: KeyboardEvent }) => {\n  if (event.key === 'ArrowUp') {\n    selectedIndex.value = (selectedIndex.value + props.items.length - 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'ArrowDown') {\n    selectedIndex.value = (selectedIndex.value + 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'Enter') {\n    selectItem(selectedIndex.value)\n    return true\n  }\n\n  return false\n}\n\ndefineExpose({\n  onKeyDown,\n})\n</script>\n\n<template>\n  <div class=\"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95\">\n    <div\n      v-for=\"(item, index) in items\"\n      :key=\"index\"\n      :class=\"cn(\n        'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors',\n        index === selectedIndex ? 'bg-accent text-accent-foreground' : 'hover:bg-accent/50'\n      )\"\n      @click=\"selectItem(index)\"\n    >\n      <FileIcon class=\"mr-2 h-4 w-4 text-muted-foreground\" />\n      <span>{{ item.label }}</span>\n    </div>\n    <div v-if=\"items.length === 0\" class=\"p-2 text-sm text-muted-foreground\">\n      No results\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/mention/suggestion.ts",
      "type": "registry:component",
      "content": "import { VueRenderer } from '@tiptap/vue-3'\nimport tippy from 'tippy.js'\nimport MentionList from './MentionList.vue'\n\nexport default {\n  items: ({ query }: { query: string }) => {\n    // Mock data\n    return [\n      { id: '1', label: 'App.vue' },\n      { id: '2', label: 'main.ts' },\n      { id: '3', label: 'utils.ts' },\n      { id: '4', label: 'api.ts' },\n      { id: '5', label: 'router.ts' },\n      { id: '6', label: 'AIInput.vue' },\n    ].filter(item => item.label.toLowerCase().includes(query.toLowerCase()))\n  },\n\n  command: ({ editor, range, props }: any) => {\n    // Increase range.to by one when the next node is of type \"text\"\n    // and starts with a space character\n    const nodeAfter = editor.view.state.selection.$to.nodeAfter\n    const overrideSpace = nodeAfter?.text?.startsWith(' ')\n\n    if (overrideSpace) {\n      range.to += 1\n    }\n\n    editor\n      .chain()\n      .focus()\n      .insertContentAt(range, [\n        {\n          type: 'contextItem',\n          attrs: {\n            id: props.id,\n            label: props.label,\n            type: 'file', // Default type for now\n          },\n        },\n        {\n          type: 'text',\n          text: ' ',\n        },\n      ])\n      .run()\n\n    window.getSelection()?.collapseToEnd()\n  },\n\n  render: () => {\n    let component: VueRenderer\n    let popup: any\n\n    return {\n      onStart: (props: any) => {\n        component = new VueRenderer(MentionList, {\n          props,\n          editor: props.editor,\n        })\n\n        if (!props.clientRect) {\n          return\n        }\n\n        popup = tippy('body', {\n          getReferenceClientRect: props.clientRect,\n          appendTo: () => document.body,\n          content: component.element,\n          showOnCreate: true,\n          interactive: true,\n          trigger: 'manual',\n          placement: 'bottom-start',\n        })\n      },\n\n      onUpdate: (props: any) => {\n        component.updateProps(props)\n\n        if (!props.clientRect) {\n          return\n        }\n\n        popup[0].setProps({\n          getReferenceClientRect: props.clientRect,\n        })\n      },\n\n      onKeyDown: (props: any) => {\n        if (props.event.key === 'Escape') {\n          popup[0].hide()\n          return true\n        }\n\n        return component.ref?.onKeyDown(props)\n      },\n\n      onExit: () => {\n        popup[0].destroy()\n        component.destroy()\n      },\n    }\n  },\n}\n"
    },
    {
      "path": "ui/ai-input/extensions/slash-command/CommandList.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { ref, watch, onMounted } from 'vue'\nimport { cn } from '@/lib/utils'\nimport type { PromptShortcut } from './types'\n\nconst props = defineProps<{\n  items: PromptShortcut[]\n  command: (item: PromptShortcut) => void\n}>()\n\nconst selectedIndex = ref(0)\n\nwatch(() => props.items, () => {\n  selectedIndex.value = 0\n})\n\nconst onKeyDown = ({ event }: { event: KeyboardEvent }) => {\n  if (event.key === 'ArrowUp') {\n    selectedIndex.value = ((selectedIndex.value + props.items.length) - 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'ArrowDown') {\n    selectedIndex.value = (selectedIndex.value + 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'Enter') {\n    selectItem(selectedIndex.value)\n    return true\n  }\n  \n  if (event.key === 'Tab') {\n    event.preventDefault()\n    event.stopPropagation()\n    selectItem(selectedIndex.value)\n    return true\n  }\n\n  return false\n}\n\nconst selectItem = (index: number) => {\n  const item = props.items[index]\n  if (item) {\n    props.command(item)\n  }\n}\n\ndefineExpose({\n  onKeyDown,\n})\n</script>\n\n<template>\n  <div class=\"z-50 min-w-[300px] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95\">\n    <div v-if=\"items.length === 0\" class=\"p-2 text-sm text-muted-foreground text-center\">\n      No commands found\n    </div>\n    \n    <div\n      v-for=\"(item, index) in items\"\n      :key=\"index\"\n      :class=\"cn(\n        'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none',\n        index === selectedIndex ? 'bg-accent text-accent-foreground' : ''\n      )\"\n      @click=\"selectItem(index)\"\n      @mouseenter=\"selectedIndex = index\"\n    >\n      <component :is=\"item.icon\" v-if=\"item.icon\" class=\"mr-2 h-4 w-4\" />\n      <div class=\"flex flex-col flex-1 gap-0.5\">\n        <span class=\"font-medium\">{{ item.label }}</span>\n        <span v-if=\"item.description\" class=\"text-xs text-muted-foreground/80 truncate\">\n          {{ item.description }}\n        </span>\n      </div>\n      <kbd v-if=\"index === selectedIndex\" class=\"ml-auto text-[10px] text-muted-foreground font-mono bg-muted px-1 rounded\">\n        \n      </kbd>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/slash-command/index.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\nimport Suggestion from '@tiptap/suggestion'\nimport { VueRenderer } from '@tiptap/vue-3'\nimport tippy from 'tippy.js'\nimport CommandList from './CommandList.vue'\nimport type { SlashCommandOptions, PromptShortcut } from './types'\nimport { defaultShortcuts } from './shortcuts'\nimport { PluginKey } from '@tiptap/pm/state'\n\nexport const SlashCommand = Extension.create<SlashCommandOptions>({\n  name: 'slashCommand',\n\n  addOptions() {\n    return {\n      char: '/',\n      shortcuts: defaultShortcuts,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      Suggestion({\n        editor: this.editor,\n        char: this.options.char,\n        pluginKey: new PluginKey('slashCommand'), // Explicit key to separate from Mentions\n        \n        items: ({ query }) => {\n          return this.options.shortcuts\n            .filter(item => \n              item.label.toLowerCase().includes(query.toLowerCase()) || \n              item.key.toLowerCase().includes(query.toLowerCase())\n            )\n            .slice(0, 10)\n        },\n\n        command: ({ editor, range, props }) => {\n          const item = props as PromptShortcut\n          \n          // Delete the slash command text\n          editor.chain().focus().deleteRange(range).run()\n          \n          // Insert the template content\n          // If template is a function, call it (future proofing for dynamic templates)\n          const content = typeof item.template === 'function' \n            ? item.template() \n            : item.template\n            \n          // We need to unwrap the 'doc' if it exists, as insertContent expects nodes/array\n          const nodesToInsert = content.type === 'doc' && content.content \n            ? content.content \n            : content\n\n          editor.chain().insertContent(nodesToInsert).run()\n        },\n\n        render: () => {\n          let component: VueRenderer\n          let popup: any\n\n          return {\n            onStart: (props) => {\n              component = new VueRenderer(this.options.component || CommandList, {\n                props,\n                editor: props.editor,\n              })\n\n              if (!props.clientRect) {\n                return\n              }\n\n              popup = tippy('body', {\n                getReferenceClientRect: props.clientRect as any,\n                appendTo: () => document.body,\n                content: component.element,\n                showOnCreate: true,\n                interactive: true,\n                trigger: 'manual',\n                placement: 'bottom-start',\n                zIndex: 9999, // Ensure it's above other elements\n              })\n            },\n\n            onUpdate: (props) => {\n              component.updateProps(props)\n\n              if (!props.clientRect) {\n                return\n              }\n\n              popup[0].setProps({\n                getReferenceClientRect: props.clientRect,\n              })\n            },\n\n            onKeyDown: (props) => {\n              if (props.event.key === 'Escape') {\n                popup[0].hide()\n                return true\n              }\n              // @ts-ignore\n              return component.ref?.onKeyDown(props)\n            },\n\n            onExit: () => {\n              popup[0].destroy()\n              component.destroy()\n            },\n          }\n        },\n      }),\n    ]\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/slash-command/shortcuts.ts",
      "type": "registry:component",
      "content": "import { BugIcon, DatabaseIcon, CodeIcon, SparklesIcon } from 'lucide-vue-next'\nimport type { PromptShortcut } from './types'\n\nexport const defaultShortcuts: PromptShortcut[] = [\n  {\n    key: 'bug',\n    label: 'Bug Analysis',\n    description: 'Analyze code for potential bugs and security issues',\n    icon: BugIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Please analyze the following code for bugs: ' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Paste Code Here',\n            metadata: { placeholder: 'Code snippet...' } \n          } \n        },\n        { type: 'hardBreak' },\n        { type: 'text', text: 'Focus on: ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Focus Area',\n            metadata: { \n              value: 'security',\n              options: [\n                { label: 'Security', value: 'security' },\n                { label: 'Performance', value: 'performance' },\n                { label: 'Logic', value: 'logic' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  },\n  {\n    key: 'sql',\n    label: 'SQL Generator',\n    description: 'Generate SQL queries for specific databases',\n    icon: DatabaseIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Generate a SQL query for ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Database',\n            metadata: { \n              value: 'postgresql',\n              options: [\n                { label: 'PostgreSQL', value: 'postgresql' },\n                { label: 'MySQL', value: 'mysql' },\n                { label: 'Oracle', value: 'oracle' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ' to: ' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Requirement',\n            metadata: { placeholder: 'Describe what you need...' } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  },\n  {\n    key: 'refactor',\n    label: 'Refactor Code',\n    description: 'Improve code quality and readability',\n    icon: SparklesIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Refactor this code to be more ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Goal',\n            metadata: { \n              value: 'readable',\n              options: [\n                { label: 'Readable', value: 'readable' },\n                { label: 'Efficient', value: 'efficient' },\n                { label: 'Modern', value: 'modern' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ':' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Code',\n            metadata: { placeholder: 'Code...' } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  },\n  {\n    key: 'explain',\n    label: 'Explain Code',\n    description: 'Explain what a piece of code does',\n    icon: CodeIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Explain what this code does in ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Language',\n            metadata: { \n              value: 'english',\n              options: [\n                { label: 'English', value: 'english' },\n                { label: 'Chinese', value: 'chinese' },\n                { label: 'Japanese', value: 'japanese' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ':' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Code',\n            metadata: { placeholder: 'Paste code...' } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  }\n]\n"
    },
    {
      "path": "ui/ai-input/extensions/slash-command/types.ts",
      "type": "registry:component",
      "content": "import type { Component } from 'vue'\nimport type { JSONContent } from '@tiptap/core'\n\nexport interface PromptShortcut {\n  // Trigger key (e.g. 'bug', 'sql')\n  key: string\n  // Display label in menu\n  label: string\n  // Description in menu\n  description?: string\n  // Icon component\n  icon?: Component \n  \n  // The content to insert\n  template: JSONContent | ((args?: any) => JSONContent)\n}\n\nexport interface SlashCommandOptions {\n  char: string\n  shortcuts: PromptShortcut[]\n  component?: Component\n}\n"
    },
    {
      "path": "ui/ai-input/hooks/use-editor-state.ts",
      "type": "registry:component",
      "content": "import { ref, computed, watch, onBeforeUnmount } from 'vue'\nimport { useEditor, Extension, type Editor } from '@tiptap/vue-3'\nimport StarterKit from '@tiptap/starter-kit'\nimport Placeholder from '@tiptap/extension-placeholder'\nimport Mention from '@tiptap/extension-mention'\nimport { ContextItem } from '../extensions/context-item'\nimport { FileHandler } from '../extensions/file-handler'\nimport { HistoryNavigation } from '../extensions/history'\nimport mentionSuggestion from '../extensions/mention/suggestion'\nimport { SlashCommand } from '../extensions/slash-command'\nimport type { AttachmentFile } from '../core/types'\nimport type { AnyExtension } from '@tiptap/core'\n\nexport interface Locale {\n  placeholder: string\n}\n\nexport const defaultLocale: Locale = {\n  placeholder: 'Ask AI anything... (Type @ for mention, / for templates)'\n}\n\nexport interface UseEditorStateOptions {\n  history?: string[]\n  placeholder?: string\n  locale?: Partial<Locale>\n  onSubmit?: () => void\n  onAddFiles?: (files: File[]) => void\n  extensions?: (defaultExtensions: AnyExtension[]) => AnyExtension[]\n}\n\nexport function useEditorState(options: UseEditorStateOptions = {}) {\n  const historyIndex = ref(-1)\n  const draft = ref('')\n  \n  const locale = computed(() => ({\n    ...defaultLocale,\n    ...options.locale\n  }))\n  \n  // Define SubmitShortcut extension locally\n  const SubmitShortcut = Extension.create({\n    name: 'submitShortcut',\n    priority: 0,\n    addKeyboardShortcuts() {\n      return {\n        Enter: () => {\n          if (document.querySelector('.tippy-box[data-state=\"visible\"]')) {\n            return false\n          }\n          options.onSubmit?.()\n          return true\n        }\n      }\n    }\n  })\n\n  const getDefaultExtensions = () => [\n      StarterKit,\n      Placeholder.configure({\n        placeholder: options.placeholder || locale.value.placeholder,\n        emptyEditorClass: 'is-editor-empty',\n      }),\n      ContextItem,\n      FileHandler.configure({\n        onDrop: (files: File[]) => {\n          options.onAddFiles?.(files)\n        },\n        onPaste: (files: File[]) => {\n          options.onAddFiles?.(files)\n        },\n        onReferenceDrop: (refData: any, pos: number) => {\n          editor.value?.chain().focus().insertContentAt(pos, {\n            type: 'contextItem',\n            attrs: {\n              id: refData.id,\n              label: refData.name,\n              type: 'file',\n              metadata: { originalType: refData.type }\n            }\n          }).run()\n        }\n      }),\n      HistoryNavigation.configure({\n        onUp: () => {\n          const history = options.history || []\n          if (!history.length) return false\n\n          if (historyIndex.value === -1) {\n            draft.value = editor.value?.getHTML() || ''\n          }\n\n          const nextIndex = historyIndex.value + 1\n          if (nextIndex < history.length) {\n            historyIndex.value = nextIndex\n            const item = history[history.length - 1 - nextIndex]\n            editor.value?.commands.setContent(item)\n            editor.value?.commands.focus('end')\n            return true\n          }\n          return false\n        },\n        onDown: () => {\n          if (historyIndex.value > -1) {\n            const nextIndex = historyIndex.value - 1\n            historyIndex.value = nextIndex\n            \n            const history = options.history || []\n\n            if (nextIndex === -1) {\n              editor.value?.commands.setContent(draft.value)\n            } else {\n              const item = history[history.length - 1 - nextIndex]\n              editor.value?.commands.setContent(item)\n            }\n            editor.value?.commands.focus('end')\n            return true\n          }\n          return false\n        }\n      }),\n      SlashCommand,\n      Mention.configure({\n        HTMLAttributes: {\n          class: 'mention',\n        },\n        suggestion: mentionSuggestion,\n      }),\n      SubmitShortcut\n    ]\n\n  const extensions = computed(() => {\n    const defaults = getDefaultExtensions() as AnyExtension[]\n    return options.extensions ? options.extensions(defaults) : defaults\n  })\n\n  const editor = useEditor({\n    extensions: extensions.value,\n    editorProps: {\n      attributes: {\n        class: 'prose prose-sm dark:prose-invert max-w-none focus:outline-none min-h-[60px] max-h-[200px] overflow-y-auto px-4 py-3',\n      },\n    },\n  })\n\n  // Cleanup\n  onBeforeUnmount(() => {\n    editor.value?.destroy()\n  })\n\n  return {\n    editor\n  }\n}\n"
    },
    {
      "path": "ui/ai-input/hooks/use-file-upload.ts",
      "type": "registry:component",
      "content": "import { ref, computed } from 'vue'\nimport { nanoid } from 'nanoid'\nimport type { AttachmentFile, UploadHandler } from '../types'\n\nexport interface UseFileUploadOptions {\n  handler?: UploadHandler\n  maxSize?: number\n  maxFiles?: number\n  accept?: string\n}\n\nexport function useFileUpload(options: UseFileUploadOptions = {}) {\n  const files = ref<AttachmentFile[]>([])\n  \n  const isUploading = computed(() => files.value.some(f => f.status === 'uploading'))\n\n  const processFile = async (attachment: AttachmentFile) => {\n    if (!options.handler || !attachment.file) {\n      // If no handler, mark as done immediately (local mode)\n      attachment.status = 'done'\n      attachment.progress = 100\n      return\n    }\n\n    attachment.status = 'uploading'\n    attachment.progress = 0\n    attachment.error = undefined\n\n    try {\n      const result = await options.handler(attachment.file, (progress) => {\n        attachment.progress = progress\n      })\n      attachment.status = 'done'\n      attachment.serverData = result\n      attachment.progress = 100\n    } catch (err) {\n      console.error('Upload failed', err)\n      attachment.status = 'error'\n      attachment.error = err instanceof Error ? err : new Error('Upload failed')\n    }\n  }\n\n  const addFiles = async (newFiles: File[] | FileList) => {\n    const fileArray = Array.from(newFiles)\n    \n    // TODO: Add validation logic here (maxSize, accept, maxFiles)\n    \n    const newAttachments: AttachmentFile[] = fileArray.map(file => ({\n      id: nanoid(),\n      file,\n      name: file.name,\n      type: file.type,\n      status: 'pending',\n      progress: 0\n    }))\n    \n    files.value = [...files.value, ...newAttachments]\n    \n    // Start uploads\n    await Promise.all(newAttachments.map(processFile))\n  }\n\n  const retryUpload = (id: string) => {\n    const file = files.value.find(f => f.id === id)\n    if (file) {\n      processFile(file)\n    }\n  }\n\n  const removeFile = (id: string) => {\n    files.value = files.value.filter(f => f.id !== id)\n  }\n\n  const clearFiles = () => {\n    files.value = []\n  }\n\n  return {\n    files,\n    isUploading,\n    addFiles,\n    retryUpload,\n    removeFile,\n    clearFiles\n  }\n}\n"
    },
    {
      "path": "ui/ai-input/hooks/use-voice.ts",
      "type": "registry:component",
      "content": "import { ref, onMounted, onUnmounted } from 'vue'\n\nexport type VoiceState = 'idle' | 'listening' | 'processing'\n\n// Basic type definitions for Web Speech API since they might not be in standard lib yet\ninterface SpeechRecognitionEvent extends Event {\n  results: SpeechRecognitionResultList\n  resultIndex: number\n  interpretation: any\n}\n\ninterface SpeechRecognitionErrorEvent extends Event {\n  error: string\n  message: string\n}\n\ninterface SpeechRecognition extends EventTarget {\n  continuous: boolean\n  interimResults: boolean\n  lang: string\n  start(): void\n  stop(): void\n  abort(): void\n  onstart: (event: Event) => void\n  onend: (event: Event) => void\n  onresult: (event: SpeechRecognitionEvent) => void\n  onerror: (event: SpeechRecognitionErrorEvent) => void\n}\n\ninterface SpeechRecognitionConstructor {\n  new (): SpeechRecognition\n}\n\ndeclare global {\n  interface Window {\n    SpeechRecognition?: SpeechRecognitionConstructor\n    webkitSpeechRecognition?: SpeechRecognitionConstructor\n  }\n}\n\nexport function useVoice(onResult: (text: string) => void) {\n  const state = ref<VoiceState>('idle')\n  const recognition = ref<SpeechRecognition | null>(null)\n  const isSupported = ref(false)\n\n  onMounted(() => {\n    // Check browser support\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition\n\n    if (SpeechRecognition) {\n      isSupported.value = true\n      const sr = new SpeechRecognition()\n      sr.continuous = true\n      sr.interimResults = true\n      sr.lang = 'en-US'\n\n      sr.onstart = () => {\n        state.value = 'listening'\n      }\n\n      sr.onend = () => {\n        state.value = 'idle'\n      }\n\n      sr.onresult = (event: SpeechRecognitionEvent) => {\n        let finalTranscript = ''\n        for (let i = event.resultIndex; i < event.results.length; i++) {\n          const result = event.results[i]\n          if (result.isFinal) {\n            finalTranscript += result[0]?.transcript ?? ''\n          }\n        }\n\n        if (finalTranscript) {\n          onResult(finalTranscript)\n        }\n      }\n\n      sr.onerror = (event: SpeechRecognitionErrorEvent) => {\n        console.error('Speech recognition error:', event.error)\n        state.value = 'idle'\n      }\n\n      recognition.value = sr\n    }\n  })\n\n  onUnmounted(() => {\n    if (recognition.value && state.value === 'listening') {\n      recognition.value.stop()\n    }\n  })\n\n  const start = () => {\n    if (!isSupported.value || state.value === 'listening') return\n    try {\n      recognition.value?.start()\n    } catch (e) {\n      console.error('Failed to start speech recognition', e)\n    }\n  }\n\n  const stop = () => {\n    if (state.value !== 'listening') return\n    recognition.value?.stop()\n  }\n\n  const toggle = () => {\n    if (state.value === 'listening') {\n      stop()\n    } else {\n      start()\n    }\n  }\n\n  return {\n    state,\n    isSupported,\n    start,\n    stop,\n    toggle,\n  }\n}\n"
    },
    {
      "path": "ui/ai-input/index.ts",
      "type": "registry:component",
      "content": "export { default as AIInput } from './components/AIInput.vue'\nexport { default as AIInputEditor } from './components/AIInputEditor.vue'\nexport { default as AIInputToolbar } from './components/AIInputToolbar.vue'\nexport { default as AIInputVoice } from './components/AIInputVoice.vue'\nexport { default as AIInputAttachButton } from './components/AIInputAttachButton.vue'\nexport * from './core/context'\nexport * from './core/types'\nexport { default as ContextItemView } from './extensions/context-item/ContextItemView.vue'\nexport { ContextItem } from './extensions/context-item'\nexport { FileHandler } from './extensions/file-handler'\nexport { HistoryNavigation } from './extensions/history'\nexport { useVoice } from './hooks/use-voice'\n"
    },
    {
      "path": "ui/ai-input/types/index.ts",
      "type": "registry:component",
      "content": "// Core types\nexport * from '../types'\n\n// Registry types\nexport * from '../registry/types'\n\n// Extension types\nexport * from '../extensions/SlashCommand/types'\n"
    }
  ]
}