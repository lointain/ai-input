{
  "name": "ai-input",
  "type": "registry:component",
  "title": "AI Input",
  "description": "A Notion-style AI input with drag & drop, slash commands, and mentions.",
  "dependencies": [
    "@tiptap/vue-3",
    "@tiptap/starter-kit",
    "@tiptap/extension-placeholder",
    "@tiptap/extension-mention",
    "lucide-vue-next",
    "tippy.js"
  ],
  "registryDependencies": [
    "button",
    "badge",
    "card",
    "separator"
  ],
  "files": [
    {
      "path": "ui/ai-input/AIInput.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { useAIInputProvider, type AIInputProps } from './context'\nimport AIInputAttachments from './AIInputAttachments.vue'\n\ninterface Props extends AIInputProps {\n  class?: HTMLAttributes['class']\n}\n\nconst props = defineProps<Props>()\n\nconst { fileInputRef, addFiles } = useAIInputProvider(props)\n\nfunction onFileChange(e: Event) {\n  const input = e.target as HTMLInputElement\n  if (input.files) {\n    addFiles(input.files)\n  }\n  input.value = ''\n}\n\nfunction handleDragOver(e: DragEvent) {\n  if (e.dataTransfer?.types?.includes('Files')) {\n    e.preventDefault()\n  }\n}\n\nfunction handleDrop(e: DragEvent) {\n  if (e.dataTransfer?.types?.includes('Files')) {\n    e.preventDefault()\n    \n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      addFiles(e.dataTransfer.files)\n    }\n  }\n}\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'relative flex w-full flex-col overflow-hidden rounded-xl border bg-background focus-within:ring-1 focus-within:ring-ring',\n      props.class,\n    )\"\n    @dragover=\"handleDragOver\"\n    @drop=\"handleDrop\"\n  >\n    <input\n      ref=\"fileInputRef\"\n      type=\"file\"\n      class=\"hidden\"\n      multiple\n      @change=\"onFileChange\"\n    >\n    <AIInputAttachments />\n    <slot />\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/AIInputAttachButton.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/ui/button'\nimport { PaperclipIcon } from 'lucide-vue-next'\nimport { useAIInputContext } from './context'\n\nconst { fileInputRef } = useAIInputContext()\n\nconst onClick = () => {\n  fileInputRef.value?.click()\n}\n</script>\n\n<template>\n  <Button\n    variant=\"ghost\"\n    size=\"icon\"\n    class=\"h-8 w-8 rounded-full\"\n    @click=\"onClick\"\n  >\n    <PaperclipIcon class=\"h-4 w-4\" />\n  </Button>\n</template>\n"
    },
    {
      "path": "ui/ai-input/AIInputAttachments.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { cn } from '@/lib/utils'\nimport { FileIcon, XIcon, RefreshCwIcon, AlertCircleIcon } from 'lucide-vue-next'\nimport { useAIInputContext } from './context'\nimport { computed } from 'vue'\n\nconst props = defineProps<{\n  class?: string\n}>()\n\nconst { files, removeFile, retryUpload } = useAIInputContext()\n\nconst hasFiles = computed(() => files.value.length > 0)\n</script>\n\n<template>\n  <div\n    v-if=\"hasFiles\"\n    :class=\"cn('flex flex-wrap items-center gap-2 p-3 w-full border-b bg-muted/30', props.class)\"\n  >\n    <div\n      v-for=\"file in files\"\n      :key=\"file.id\"\n      class=\"group relative flex items-center gap-2 rounded-lg border bg-background px-3 py-2 text-sm shadow-sm transition-all hover:shadow-md\"\n    >\n      <!-- Icon based on status -->\n      <div class=\"relative flex h-8 w-8 items-center justify-center rounded bg-muted\">\n        <AlertCircleIcon v-if=\"file.status === 'error'\" class=\"h-4 w-4 text-destructive\" />\n        <FileIcon v-else class=\"h-4 w-4 text-muted-foreground\" />\n        \n        <!-- Progress Overlay -->\n        <div \n          v-if=\"file.status === 'uploading'\"\n          class=\"absolute inset-0 bg-background/50 flex items-center justify-center\"\n        >\n          <div \n            class=\"h-full w-full bg-primary/20 absolute bottom-0 left-0\"\n            :style=\"{ height: `${file.progress}%` }\"\n          />\n        </div>\n      </div>\n\n      <div class=\"flex flex-col max-w-[150px]\">\n        <span class=\"truncate font-medium text-xs\">{{ file.name }}</span>\n        <span class=\"text-[10px] text-muted-foreground flex items-center gap-1\">\n          <template v-if=\"file.status === 'uploading'\">\n            Uploading {{ file.progress }}%\n          </template>\n          <template v-else-if=\"file.status === 'error'\">\n            Failed\n          </template>\n          <template v-else>\n            {{ (file.file?.size ? (file.file.size / 1024).toFixed(1) + ' KB' : '') }}\n          </template>\n        </span>\n      </div>\n\n      <!-- Actions -->\n      <div class=\"flex items-center gap-1\">\n        <button\n          v-if=\"file.status === 'error'\"\n          type=\"button\"\n          class=\"rounded-full p-1 hover:bg-muted text-muted-foreground hover:text-foreground\"\n          @click=\"retryUpload(file.id)\"\n        >\n          <RefreshCwIcon class=\"h-3 w-3\" />\n        </button>\n        \n        <button\n          type=\"button\"\n          class=\"rounded-full p-1 hover:bg-muted text-muted-foreground hover:text-foreground\"\n          @click=\"removeFile(file.id)\"\n        >\n          <XIcon class=\"h-3 w-3\" />\n        </button>\n      </div>\n\n      <!-- Progress Bar (Bottom Line) -->\n      <div \n        v-if=\"file.status === 'uploading'\"\n        class=\"absolute bottom-0 left-0 h-0.5 bg-primary transition-all duration-300\"\n        :style=\"{ width: `${file.progress}%` }\"\n      />\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/AIInputEditor.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { useEditor, EditorContent, Extension } from '@tiptap/vue-3'\nimport StarterKit from '@tiptap/starter-kit'\nimport Placeholder from '@tiptap/extension-placeholder'\nimport Mention from '@tiptap/extension-mention'\nimport { onBeforeUnmount, ref, watch } from 'vue'\nimport { useAIInputContext } from './context'\nimport { ContextItem } from './extensions/ContextItem'\nimport { FileHandler } from './extensions/FileHandler'\nimport { HistoryNavigation } from './extensions/HistoryNavigation'\nimport mentionSuggestion from './extensions/mentionSuggestion'\nimport { SlashCommand } from './extensions/SlashCommand'\n\nconst { setEditor, submit, isDisabled, addFiles, history } = useAIInputContext()\n\nconst historyIndex = ref(-1)\nconst draft = ref('')\n\n// Define SubmitShortcut extension locally to handle Enter key with correct priority\nconst SubmitShortcut = Extension.create({\n  name: 'submitShortcut',\n  priority: 0, // Low priority to let other extensions (like SlashCommand) handle keys first\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => {\n        // Safety check: Do not submit if any Tippy popup (suggestion menu) is open\n        // This acts as a fallback if the suggestion plugin failed to trap the key\n        if (document.querySelector('.tippy-box[data-state=\"visible\"]')) {\n          return false // Let default behavior happen (or nothing)\n        }\n\n        submit()\n        return true // Prevent default behavior (newline)\n      }\n    }\n  }\n})\n\nconst editor = useEditor({\n  extensions: [\n    StarterKit,\n    Placeholder.configure({\n      placeholder: 'Ask AI anything... (Type @ for mention, / for templates)',\n      emptyEditorClass: 'is-editor-empty',\n    }),\n    ContextItem,\n    FileHandler.configure({\n      onDrop: (files, pos) => {\n        addFiles(files)\n      },\n      onPaste: (files) => {\n        addFiles(files)\n      },\n      onReferenceDrop: (refData, pos) => {\n        // Handle internal reference drop\n        editor.value?.chain().focus().insertContentAt(pos, {\n            type: 'contextItem',\n            attrs: {\n                id: refData.id,\n                label: refData.name,\n                type: 'file',\n                metadata: { originalType: refData.type }\n            }\n        }).run()\n      }\n    }),\n    HistoryNavigation.configure({\n      onUp: () => {\n        if (!history.value.length)\n          return false\n\n        if (historyIndex.value === -1) {\n          draft.value = editor.value?.getHTML() || ''\n        }\n\n        const nextIndex = historyIndex.value + 1\n        if (nextIndex < history.value.length) {\n          historyIndex.value = nextIndex\n          const item = history.value[history.value.length - 1 - nextIndex]\n          editor.value?.commands.setContent(item)\n          editor.value?.commands.focus('end')\n          return true\n        }\n        return false\n      },\n      onDown: () => {\n        if (historyIndex.value > -1) {\n          const nextIndex = historyIndex.value - 1\n          historyIndex.value = nextIndex\n\n          if (nextIndex === -1) {\n            editor.value?.commands.setContent(draft.value)\n          }\n          else {\n            const item = history.value[history.value.length - 1 - nextIndex]\n            editor.value?.commands.setContent(item)\n          }\n          editor.value?.commands.focus('end')\n          return true\n        }\n        return false\n      },\n    }),\n    Mention.configure({\n      HTMLAttributes: {\n        class: 'mention',\n      },\n      suggestion: {\n        ...mentionSuggestion,\n        command: ({ editor, range, props }) => {\n          editor\n            .chain()\n            .focus()\n            .insertContentAt(range, [\n              {\n                type: 'contextItem',\n                attrs: {\n                  id: props.id,\n                  label: props.label,\n                  type: 'file',\n                },\n              },\n            ])\n            .run()\n        },\n      },\n    }),\n    SlashCommand.configure({\n      priority: 100, // Ensure high priority\n    }),\n    SubmitShortcut, // Add our new extension\n  ],\n  editorProps: {\n    attributes: {\n      class: 'prose prose-sm dark:prose-invert max-w-none focus:outline-none min-h-[60px] p-3 max-h-[400px] overflow-y-auto',\n    },\n  },\n  onUpdate: () => {\n    //\n  },\n})\n\nwatch(editor, (val) => {\n  if (val) setEditor(val)\n}, { immediate: true })\n\n// Update editable state\nwatch(isDisabled, (val) => {\n  editor.value?.setEditable(!val)\n})\n\nonBeforeUnmount(() => {\n  editor.value?.destroy()\n})\n</script>\n\n<template>\n  <div class=\"relative w-full\">\n    <EditorContent :editor=\"editor\" />\n  </div>\n</template>\n\n<style>\n/* Placeholder styles */\n.ProseMirror p.is-editor-empty:first-child::before {\n  color: hsl(var(--muted-foreground));\n  content: attr(data-placeholder);\n  float: left;\n  height: 0;\n  pointer-events: none;\n}\n</style>\n"
    },
    {
      "path": "ui/ai-input/AIInputToolbar.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/ui/button'\nimport { ArrowUpIcon, SquareIcon } from 'lucide-vue-next'\nimport { useAIInputContext } from './context'\nimport { cn } from '@/lib/utils'\n\nconst { submit, isLoading, isEmpty } = useAIInputContext()\n</script>\n\n<template>\n  <div class=\"flex items-center justify-between p-2\">\n    <div class=\"flex items-center gap-2\">\n      <!-- Left slots (attachments, voice, etc.) -->\n      <slot name=\"left\" />\n    </div>\n    \n    <div class=\"flex items-center gap-2\">\n      <!-- Right slots -->\n      <slot name=\"right\" />\n      \n      <Button\n        size=\"icon\"\n        :variant=\"isLoading ? 'outline' : 'default'\"\n        :disabled=\"isEmpty && !isLoading\"\n        :class=\"cn('h-8 w-8 rounded-full transition-all', isLoading && 'animate-pulse')\"\n        @click=\"submit\"\n      >\n        <SquareIcon v-if=\"isLoading\" class=\"h-4 w-4 fill-current\" />\n        <ArrowUpIcon v-else class=\"h-4 w-4\" />\n      </Button>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/AIInputVoice.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { Button } from '@/components/ui/button'\nimport { MicIcon } from 'lucide-vue-next'\nimport { useVoice } from './useVoice'\nimport { useAIInputContext } from './context'\nimport { cn } from '@/lib/utils'\n\nconst { editor } = useAIInputContext()\n\nconst { state, toggle, isSupported } = useVoice((text) => {\n  if (editor.value) {\n    editor.value.chain().focus().insertContent(text + ' ').run()\n  }\n})\n</script>\n\n<template>\n  <Button\n    v-if=\"isSupported\"\n    size=\"icon\"\n    variant=\"ghost\"\n    :class=\"cn('h-8 w-8 rounded-full transition-all', state === 'listening' && 'bg-red-100 text-red-600 hover:bg-red-100 hover:text-red-700 dark:bg-red-900/30 dark:text-red-400')\"\n    @click=\"toggle\"\n  >\n    <MicIcon v-if=\"state !== 'listening'\" class=\"h-4 w-4\" />\n    <div v-else class=\"flex items-center gap-0.5\">\n      <div class=\"h-2 w-0.5 animate-bounce bg-current [animation-delay:-0.3s]\" />\n      <div class=\"h-3 w-0.5 animate-bounce bg-current [animation-delay:-0.15s]\" />\n      <div class=\"h-2 w-0.5 animate-bounce bg-current\" />\n    </div>\n  </Button>\n</template>\n"
    },
    {
      "path": "ui/ai-input/context.ts",
      "type": "registry:component",
      "content": "import { inject, provide, ref, computed } from 'vue'\nimport type { Editor } from '@tiptap/vue-3'\nimport { AI_INPUT_KEY, type AIInputContext, type AttachmentFile, type UploadHandler, type UploadResult } from './types'\nimport { nanoid } from 'nanoid'\nimport { createContextItemRegistry } from './registry'\nimport { CONTEXT_ITEM_REGISTRY_KEY } from './registry/types'\n\nexport interface AIInputProps {\n  disabled?: boolean\n  loading?: boolean\n  history?: string[]\n  uploadHandler?: UploadHandler\n  // accept, maxFiles etc. can be added here if needed for global drag validation\n  accept?: string\n  maxSize?: number\n  maxFiles?: number\n  onSubmit?: (content: string, files: AttachmentFile[]) => void\n}\n\nexport function useAIInputProvider(props: AIInputProps) {\n  const editor = ref<Editor>()\n  const files = ref<AttachmentFile[]>([])\n  const fileInputRef = ref<HTMLInputElement | null>(null)\n  \n  const isLoading = computed(() => props.loading ?? false)\n  // Disable input if parent is loading or if we are currently uploading\n  const isUploading = computed(() => files.value.some(f => f.status === 'uploading'))\n  const isDisabled = computed(() => props.disabled || isLoading.value)\n  const isEmpty = computed(() => editor.value?.isEmpty ?? true)\n  const history = computed(() => props.history || [])\n\n  // Initialize Registry\n  const registry = createContextItemRegistry()\n  provide(CONTEXT_ITEM_REGISTRY_KEY, registry)\n\n  const setEditor = (instance: Editor) => {\n    editor.value = instance\n  }\n\n  const processFile = async (attachment: AttachmentFile) => {\n    if (!props.uploadHandler || !attachment.file) {\n      // If no handler, mark as done immediately (local mode)\n      attachment.status = 'done'\n      attachment.progress = 100\n      return\n    }\n\n    attachment.status = 'uploading'\n    attachment.progress = 0\n    attachment.error = undefined\n\n    try {\n      const result = await props.uploadHandler(attachment.file, (progress) => {\n        attachment.progress = progress\n      })\n      attachment.status = 'done'\n      attachment.serverData = result\n      attachment.progress = 100\n    } catch (err) {\n      console.error('Upload failed', err)\n      attachment.status = 'error'\n      attachment.error = err instanceof Error ? err : new Error('Upload failed')\n    }\n  }\n\n  const addFiles = async (newFiles: File[] | FileList) => {\n    const fileArray = Array.from(newFiles)\n    \n    // Validation logic could go here (maxSize, accept, etc.)\n    \n    const newAttachments: AttachmentFile[] = fileArray.map(file => ({\n      id: nanoid(),\n      file,\n      name: file.name,\n      type: file.type,\n      status: 'pending',\n      progress: 0\n    }))\n    \n    files.value = [...files.value, ...newAttachments]\n    \n    // Start uploads\n    await Promise.all(newAttachments.map(processFile))\n  }\n\n  const retryUpload = (id: string) => {\n    const file = files.value.find(f => f.id === id)\n    if (file) {\n      processFile(file)\n    }\n  }\n\n  const removeFile = (id: string) => {\n    files.value = files.value.filter(f => f.id !== id)\n  }\n\n  const submit = () => {\n    if (isDisabled.value || isEmpty.value || isUploading.value) return\n    \n    // Check if any files failed\n    if (files.value.some(f => f.status === 'error')) {\n      // Could show toast here\n      return\n    }\n\n    const content = editor.value?.getHTML() || ''\n    \n    // Pass the files (which should be done)\n    props.onSubmit?.(content, files.value)\n    \n    editor.value?.commands.clearContent()\n    files.value = []\n  }\n\n  const focus = () => {\n    editor.value?.commands.focus()\n  }\n\n  const context: AIInputContext = {\n    editor,\n    files,\n    isLoading,\n    isDisabled,\n    fileInputRef,\n    setEditor,\n    addFiles,\n    removeFile,\n    submit,\n    isEmpty,\n    history,\n    focus,\n    isUploading,\n    retryUpload\n  }\n\n  provide(AI_INPUT_KEY, context)\n\n  return {\n    ...context,\n    registry // Expose registry for parent to register components\n  }\n}\n\nexport function useAIInputContext() {\n  const context = inject<AIInputContext>(AI_INPUT_KEY)\n  if (!context) {\n    throw new Error('useAIInputContext must be used within AIInput')\n  }\n  return context\n}\n"
    },
    {
      "path": "ui/ai-input/extensions/ContextItem.ts",
      "type": "registry:component",
      "content": "import { Node, mergeAttributes } from '@tiptap/core'\nimport { VueNodeViewRenderer } from '@tiptap/vue-3'\nimport ContextItemView from './ContextItemView.vue'\n\nexport const ContextItem = Node.create({\n  name: 'contextItem',\n  group: 'inline',\n  inline: true,\n  atom: true,\n\n  addAttributes() {\n    return {\n      id: {\n        default: null,\n      },\n      type: {\n        default: 'file',\n      },\n      label: {\n        default: 'Context Item',\n      },\n      metadata: {\n        default: {},\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'context-item',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['context-item', mergeAttributes(HTMLAttributes)]\n  },\n\n  addNodeView() {\n    return VueNodeViewRenderer(ContextItemView)\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/ContextItemView.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { NodeViewWrapper, nodeViewProps } from '@tiptap/vue-3'\nimport { computed, inject } from 'vue'\nimport { CONTEXT_ITEM_REGISTRY_KEY } from '../registry/types'\n\nconst props = defineProps(nodeViewProps)\n\nconst registry = inject(CONTEXT_ITEM_REGISTRY_KEY)\nconst type = computed(() => props.node.attrs.type)\n\n// Fallback safely if registry is missing (e.g. usage outside of AIInputProvider)\nconst TargetComponent = computed(() => {\n  if (!registry) return null\n  return registry.get(type.value)\n})\n</script>\n\n<template>\n  <NodeViewWrapper as=\"span\" class=\"inline-block align-middle mx-1 select-none\">\n    <component \n      v-if=\"TargetComponent\"\n      :is=\"TargetComponent\"\n      :id=\"node.attrs.id\"\n      :type=\"type\"\n      :label=\"node.attrs.label\"\n      :metadata=\"node.attrs.metadata\"\n      :selected=\"selected\"\n      :delete-node=\"deleteNode\"\n      :update-attributes=\"updateAttributes\"\n    />\n    <span v-else class=\"text-destructive text-xs border border-destructive px-1 rounded\">[Unknown: {{ type }}]</span>\n  </NodeViewWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/FileHandler.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nexport interface FileHandlerOptions {\n  onDrop?: (files: File[], pos: number) => void\n  onPaste?: (files: File[]) => void\n  onReferenceDrop?: (data: any, pos: number) => void\n}\n\nexport const FileHandler = Extension.create<FileHandlerOptions>({\n  name: 'fileHandler',\n\n  addOptions() {\n    return {\n      onDrop: undefined,\n      onPaste: undefined,\n      onReferenceDrop: undefined,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('fileHandler'),\n        props: {\n          handleDrop: (view, event, _slice, moved) => {\n            if (moved) return false\n\n            const dataTransfer = event.dataTransfer\n            if (!dataTransfer) return false\n\n            // 1. Check for Internal Reference Drop (Custom MIME type)\n            // We use 'application/x-ai-ref' to identify our own draggable items\n            const refData = dataTransfer.getData('application/x-ai-ref')\n            if (refData) {\n              event.preventDefault()\n              try {\n                const parsed = JSON.parse(refData)\n                const coords = { left: event.clientX, top: event.clientY }\n                const pos = view.posAtCoords(coords)?.pos || view.state.selection.from\n                \n                if (this.options.onReferenceDrop) {\n                  this.options.onReferenceDrop(parsed, pos)\n                }\n                return true\n              } catch (e) {\n                console.error('Failed to parse reference drop data', e)\n              }\n            }\n\n            // 2. Check for Files\n            const hasFiles = dataTransfer.files?.length\n            if (hasFiles) {\n              event.preventDefault()\n              const files = Array.from(dataTransfer.files)\n              const coords = { left: event.clientX, top: event.clientY }\n              const pos = view.posAtCoords(coords)?.pos || view.state.selection.from\n              \n              if (this.options.onDrop) {\n                this.options.onDrop(files, pos)\n              }\n              return true\n            }\n\n            return false\n          },\n          handlePaste: (view, event) => {\n             const items = event.clipboardData?.items\n             if (!items) return false\n             \n             const files: File[] = []\n             for (const item of Array.from(items)) {\n               if (item.kind === 'file') {\n                 const file = item.getAsFile()\n                 if (file) files.push(file)\n               }\n             }\n             \n             if (files.length > 0) {\n                event.preventDefault()\n                if (this.options.onPaste) {\n                    this.options.onPaste(files)\n                }\n                return true\n             }\n             return false\n          }\n        },\n      }),\n    ]\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/HistoryNavigation.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\n\nexport interface HistoryNavigationOptions {\n  onUp?: () => boolean\n  onDown?: () => boolean\n}\n\nexport const HistoryNavigation = Extension.create<HistoryNavigationOptions>({\n  name: 'historyNavigation',\n\n  addOptions() {\n    return {\n      onUp: undefined,\n      onDown: undefined,\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      ArrowUp: () => {\n        // Trigger if editor is empty or cursor is at start\n        const { selection, doc } = this.editor.state\n        const isAtStart = selection.$anchor.pos === 1\n        const isEmpty = this.editor.isEmpty\n\n        if ((isEmpty || isAtStart) && this.options.onUp) {\n          return this.options.onUp()\n        }\n        return false\n      },\n      ArrowDown: () => {\n        // Trigger if editor is empty or cursor is at end\n        const { selection, doc } = this.editor.state\n        const isAtEnd = selection.$anchor.pos === doc.content.size - 1\n        const isEmpty = this.editor.isEmpty\n\n        if ((isEmpty || isAtEnd) && this.options.onDown) {\n          return this.options.onDown()\n        }\n        return false\n      },\n    }\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/MentionList.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { ref, watch } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { FileIcon } from 'lucide-vue-next'\n\ninterface Item {\n  id: string\n  label: string\n}\n\ninterface Props {\n  items: Item[]\n  command: (props: any) => void\n}\n\nconst props = defineProps<Props>()\n\nconst selectedIndex = ref(0)\n\nwatch(() => props.items, () => {\n  selectedIndex.value = 0\n})\n\nconst selectItem = (index: number) => {\n  const item = props.items[index]\n  if (item) {\n    props.command({ id: item.id, label: item.label })\n  }\n}\n\nconst onKeyDown = ({ event }: { event: KeyboardEvent }) => {\n  if (event.key === 'ArrowUp') {\n    selectedIndex.value = (selectedIndex.value + props.items.length - 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'ArrowDown') {\n    selectedIndex.value = (selectedIndex.value + 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'Enter') {\n    selectItem(selectedIndex.value)\n    return true\n  }\n\n  return false\n}\n\ndefineExpose({\n  onKeyDown,\n})\n</script>\n\n<template>\n  <div class=\"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95\">\n    <div\n      v-for=\"(item, index) in items\"\n      :key=\"index\"\n      :class=\"cn(\n        'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors',\n        index === selectedIndex ? 'bg-accent text-accent-foreground' : 'hover:bg-accent/50'\n      )\"\n      @click=\"selectItem(index)\"\n    >\n      <FileIcon class=\"mr-2 h-4 w-4 text-muted-foreground\" />\n      <span>{{ item.label }}</span>\n    </div>\n    <div v-if=\"items.length === 0\" class=\"p-2 text-sm text-muted-foreground\">\n      No results\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/SlashCommand/CommandList.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { ref, watch, onMounted } from 'vue'\nimport { cn } from '@/lib/utils'\nimport type { PromptShortcut } from './types'\n\nconst props = defineProps<{\n  items: PromptShortcut[]\n  command: (item: PromptShortcut) => void\n}>()\n\nconst selectedIndex = ref(0)\n\nwatch(() => props.items, () => {\n  selectedIndex.value = 0\n})\n\nconst onKeyDown = ({ event }: { event: KeyboardEvent }) => {\n  if (event.key === 'ArrowUp') {\n    selectedIndex.value = ((selectedIndex.value + props.items.length) - 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'ArrowDown') {\n    selectedIndex.value = (selectedIndex.value + 1) % props.items.length\n    return true\n  }\n\n  if (event.key === 'Enter') {\n    selectItem(selectedIndex.value)\n    return true\n  }\n  \n  if (event.key === 'Tab') {\n    event.preventDefault()\n    event.stopPropagation()\n    selectItem(selectedIndex.value)\n    return true\n  }\n\n  return false\n}\n\nconst selectItem = (index: number) => {\n  const item = props.items[index]\n  if (item) {\n    props.command(item)\n  }\n}\n\ndefineExpose({\n  onKeyDown,\n})\n</script>\n\n<template>\n  <div class=\"z-50 min-w-[300px] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95\">\n    <div v-if=\"items.length === 0\" class=\"p-2 text-sm text-muted-foreground text-center\">\n      No commands found\n    </div>\n    \n    <div\n      v-for=\"(item, index) in items\"\n      :key=\"index\"\n      :class=\"cn(\n        'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none',\n        index === selectedIndex ? 'bg-accent text-accent-foreground' : ''\n      )\"\n      @click=\"selectItem(index)\"\n      @mouseenter=\"selectedIndex = index\"\n    >\n      <component :is=\"item.icon\" v-if=\"item.icon\" class=\"mr-2 h-4 w-4\" />\n      <div class=\"flex flex-col flex-1 gap-0.5\">\n        <span class=\"font-medium\">{{ item.label }}</span>\n        <span v-if=\"item.description\" class=\"text-xs text-muted-foreground/80 truncate\">\n          {{ item.description }}\n        </span>\n      </div>\n      <kbd v-if=\"index === selectedIndex\" class=\"ml-auto text-[10px] text-muted-foreground font-mono bg-muted px-1 rounded\">\n        â†µ\n      </kbd>\n    </div>\n  </div>\n</template>\n"
    },
    {
      "path": "ui/ai-input/extensions/SlashCommand/index.ts",
      "type": "registry:component",
      "content": "import { Extension } from '@tiptap/core'\nimport Suggestion from '@tiptap/suggestion'\nimport { VueRenderer } from '@tiptap/vue-3'\nimport tippy from 'tippy.js'\nimport CommandList from './CommandList.vue'\nimport type { SlashCommandOptions, PromptShortcut } from './types'\nimport { defaultShortcuts } from './shortcuts'\nimport { PluginKey } from '@tiptap/pm/state'\n\nexport const SlashCommand = Extension.create<SlashCommandOptions>({\n  name: 'slashCommand',\n\n  addOptions() {\n    return {\n      char: '/',\n      shortcuts: defaultShortcuts,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      Suggestion({\n        editor: this.editor,\n        char: this.options.char,\n        pluginKey: new PluginKey('slashCommand'), // Explicit key to separate from Mentions\n        \n        items: ({ query }) => {\n          return this.options.shortcuts\n            .filter(item => \n              item.label.toLowerCase().includes(query.toLowerCase()) || \n              item.key.toLowerCase().includes(query.toLowerCase())\n            )\n            .slice(0, 10)\n        },\n\n        command: ({ editor, range, props }) => {\n          const item = props as PromptShortcut\n          \n          // Delete the slash command text\n          editor.chain().focus().deleteRange(range).run()\n          \n          // Insert the template content\n          // If template is a function, call it (future proofing for dynamic templates)\n          const content = typeof item.template === 'function' \n            ? item.template() \n            : item.template\n            \n          // We need to unwrap the 'doc' if it exists, as insertContent expects nodes/array\n          const nodesToInsert = content.type === 'doc' && content.content \n            ? content.content \n            : content\n\n          editor.chain().insertContent(nodesToInsert).run()\n        },\n\n        render: () => {\n          let component: VueRenderer\n          let popup: any\n\n          return {\n            onStart: (props) => {\n              component = new VueRenderer(CommandList, {\n                props,\n                editor: props.editor,\n              })\n\n              if (!props.clientRect) {\n                return\n              }\n\n              popup = tippy('body', {\n                getReferenceClientRect: props.clientRect as any,\n                appendTo: () => document.body,\n                content: component.element,\n                showOnCreate: true,\n                interactive: true,\n                trigger: 'manual',\n                placement: 'bottom-start',\n                zIndex: 9999, // Ensure it's above other elements\n              })\n            },\n\n            onUpdate: (props) => {\n              component.updateProps(props)\n\n              if (!props.clientRect) {\n                return\n              }\n\n              popup[0].setProps({\n                getReferenceClientRect: props.clientRect,\n              })\n            },\n\n            onKeyDown: (props) => {\n              if (props.event.key === 'Escape') {\n                popup[0].hide()\n                return true\n              }\n\n              return component.ref?.onKeyDown(props)\n            },\n\n            onExit: () => {\n              popup[0].destroy()\n              component.destroy()\n            },\n          }\n        },\n      }),\n    ]\n  },\n})\n"
    },
    {
      "path": "ui/ai-input/extensions/SlashCommand/shortcuts.ts",
      "type": "registry:component",
      "content": "import { BugIcon, DatabaseIcon, CodeIcon, SparklesIcon } from 'lucide-vue-next'\nimport type { PromptShortcut } from './types'\n\nexport const defaultShortcuts: PromptShortcut[] = [\n  {\n    key: 'bug',\n    label: 'Bug Analysis',\n    description: 'Analyze code for potential bugs and security issues',\n    icon: BugIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Please analyze the following code for bugs: ' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Paste Code Here',\n            metadata: { placeholder: 'Code snippet...' } \n          } \n        },\n        { type: 'hardBreak' },\n        { type: 'text', text: 'Focus on: ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Focus Area',\n            metadata: { \n              value: 'security',\n              options: [\n                { label: 'Security', value: 'security' },\n                { label: 'Performance', value: 'performance' },\n                { label: 'Logic', value: 'logic' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  },\n  {\n    key: 'sql',\n    label: 'SQL Generator',\n    description: 'Generate SQL queries for specific databases',\n    icon: DatabaseIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Generate a SQL query for ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Database',\n            metadata: { \n              value: 'postgresql',\n              options: [\n                { label: 'PostgreSQL', value: 'postgresql' },\n                { label: 'MySQL', value: 'mysql' },\n                { label: 'Oracle', value: 'oracle' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ' to: ' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Requirement',\n            metadata: { placeholder: 'Describe what you need...' } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  },\n  {\n    key: 'refactor',\n    label: 'Refactor Code',\n    description: 'Improve code quality and readability',\n    icon: SparklesIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Refactor this code to be more ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Goal',\n            metadata: { \n              value: 'readable',\n              options: [\n                { label: 'Readable', value: 'readable' },\n                { label: 'Efficient', value: 'efficient' },\n                { label: 'Modern', value: 'modern' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ':' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Code',\n            metadata: { placeholder: 'Code...' } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  },\n  {\n    key: 'explain',\n    label: 'Explain Code',\n    description: 'Explain what a piece of code does',\n    icon: CodeIcon,\n    template: {\n      type: 'doc',\n      content: [\n        { type: 'text', text: 'Explain what this code does in ' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'select', \n            label: 'Language',\n            metadata: { \n              value: 'english',\n              options: [\n                { label: 'English', value: 'english' },\n                { label: 'Chinese', value: 'chinese' },\n                { label: 'Japanese', value: 'japanese' }\n              ]\n            } \n          } \n        },\n        { type: 'text', text: ':' },\n        { type: 'hardBreak' },\n        { \n          type: 'contextItem', \n          attrs: { \n            type: 'input', \n            label: 'Code',\n            metadata: { placeholder: 'Paste code...' } \n          } \n        },\n        { type: 'text', text: ' ' }\n      ]\n    }\n  }\n]\n"
    },
    {
      "path": "ui/ai-input/extensions/SlashCommand/types.ts",
      "type": "registry:component",
      "content": "import type { Component } from 'vue'\nimport type { JSONContent } from '@tiptap/core'\n\nexport interface PromptShortcut {\n  // Trigger key (e.g. 'bug', 'sql')\n  key: string\n  // Display label in menu\n  label: string\n  // Description in menu\n  description?: string\n  // Icon component\n  icon?: Component \n  \n  // The content to insert\n  template: JSONContent | ((args?: any) => JSONContent)\n}\n\nexport interface SlashCommandOptions {\n  char: string\n  shortcuts: PromptShortcut[]\n}\n"
    },
    {
      "path": "ui/ai-input/extensions/mentionSuggestion.ts",
      "type": "registry:component",
      "content": "import { VueRenderer } from '@tiptap/vue-3'\nimport tippy from 'tippy.js'\nimport MentionList from './MentionList.vue'\n\nexport default {\n  items: ({ query }: { query: string }) => {\n    // Mock data\n    return [\n      { id: '1', label: 'App.vue' },\n      { id: '2', label: 'main.ts' },\n      { id: '3', label: 'utils.ts' },\n      { id: '4', label: 'api.ts' },\n      { id: '5', label: 'router.ts' },\n      { id: '6', label: 'AIInput.vue' },\n    ].filter(item => item.label.toLowerCase().includes(query.toLowerCase()))\n  },\n\n  render: () => {\n    let component: VueRenderer\n    let popup: any\n\n    return {\n      onStart: (props: any) => {\n        component = new VueRenderer(MentionList, {\n          props,\n          editor: props.editor,\n        })\n\n        if (!props.clientRect) {\n          return\n        }\n\n        popup = tippy('body', {\n          getReferenceClientRect: props.clientRect,\n          appendTo: () => document.body,\n          content: component.element,\n          showOnCreate: true,\n          interactive: true,\n          trigger: 'manual',\n          placement: 'bottom-start',\n        })\n      },\n\n      onUpdate: (props: any) => {\n        component.updateProps(props)\n\n        if (!props.clientRect) {\n          return\n        }\n\n        popup[0].setProps({\n          getReferenceClientRect: props.clientRect,\n        })\n      },\n\n      onKeyDown: (props: any) => {\n        if (props.event.key === 'Escape') {\n          popup[0].hide()\n          return true\n        }\n\n        return component.ref?.onKeyDown(props)\n      },\n\n      onExit: () => {\n        popup[0].destroy()\n        component.destroy()\n      },\n    }\n  },\n}\n"
    },
    {
      "path": "ui/ai-input/index.ts",
      "type": "registry:component",
      "content": "export { default as AIInput } from './AIInput.vue'\nexport { default as AIInputEditor } from './AIInputEditor.vue'\nexport { default as AIInputToolbar } from './AIInputToolbar.vue'\nexport { default as AIInputVoice } from './AIInputVoice.vue'\nexport { default as AIInputAttachButton } from './AIInputAttachButton.vue'\nexport * from './context'\nexport * from './types'\nexport { default as ContextItemView } from './extensions/ContextItemView.vue'\nexport { ContextItem } from './extensions/ContextItem'\nexport { FileHandler } from './extensions/FileHandler'\nexport { HistoryNavigation } from './extensions/HistoryNavigation'\nexport { useVoice } from './useVoice'\n"
    },
    {
      "path": "ui/ai-input/registry/ContextItemWrapper.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { cn } from '@/lib/utils'\nimport { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover'\nimport { Button } from '@/components/ui/button'\nimport { TrashIcon, ExternalLinkIcon, GripVerticalIcon } from 'lucide-vue-next'\nimport type { Component } from 'vue'\n\nconst props = defineProps<{\n  id: string\n  label: string\n  icon?: Component\n  type?: string\n  metadata?: Record<string, any>\n  selected?: boolean\n  closable?: boolean\n  \n  // Actions\n  onRemove?: () => void\n  onOpen?: () => void\n}>()\n</script>\n\n<template>\n  <Popover>\n    <PopoverTrigger as-child>\n      <span\n        :class=\"cn(\n          'inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-xs font-medium transition-colors cursor-pointer select-none',\n          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',\n          props.selected && 'ring-2 ring-ring'\n        )\"\n      >\n        <component :is=\"icon\" v-if=\"icon\" class=\"h-3 w-3 opacity-70\" />\n        \n        <!-- Main Label Slot or Default -->\n        <slot name=\"trigger\">\n          <span class=\"max-w-[150px] truncate\">{{ label }}</span>\n        </slot>\n\n        <!-- Quick Remove Button (visible on hover or always) -->\n        <button\n          v-if=\"onRemove\"\n          @click.stop=\"onRemove\"\n          class=\"ml-1 rounded-full p-0.5 hover:bg-muted-foreground/20 focus:outline-none opacity-50 hover:opacity-100\"\n          contenteditable=\"false\"\n          type=\"button\"\n        >\n          <TrashIcon class=\"h-3 w-3\" />\n        </button>\n      </span>\n    </PopoverTrigger>\n    \n    <PopoverContent class=\"w-72 p-0\" align=\"start\">\n      <!-- Header -->\n      <div class=\"flex items-center justify-between border-b px-3 py-2 bg-muted/30\">\n        <div class=\"flex items-center gap-2\">\n          <component :is=\"icon\" v-if=\"icon\" class=\"h-3 w-3 text-muted-foreground\" />\n          <span class=\"font-medium text-xs\">{{ type || 'Item' }}</span>\n        </div>\n        <div class=\"flex items-center gap-1\">\n           <Button \n            v-if=\"onRemove\"\n            variant=\"ghost\" \n            size=\"icon\" \n            class=\"h-6 w-6 text-muted-foreground hover:text-destructive\"\n            @click=\"onRemove\"\n          >\n            <TrashIcon class=\"h-3 w-3\" />\n          </Button>\n        </div>\n      </div>\n\n      <!-- Body -->\n      <div class=\"p-3\">\n        <slot />\n      </div>\n\n      <!-- Footer (Metadata Debug or Extra Actions) -->\n      <div v-if=\"metadata?.url || id\" class=\"border-t px-3 py-1.5 bg-muted/10 text-[10px] text-muted-foreground flex justify-between items-center\">\n        <span class=\"font-mono opacity-50\">ID: {{ id.slice(0, 6) }}...</span>\n        <a \n          v-if=\"metadata?.url\"\n          :href=\"metadata.url\"\n          target=\"_blank\"\n          class=\"flex items-center gap-1 hover:underline hover:text-primary\"\n        >\n          Open Link <ExternalLinkIcon class=\"h-3 w-3\" />\n        </a>\n      </div>\n    </PopoverContent>\n  </Popover>\n</template>\n"
    },
    {
      "path": "ui/ai-input/registry/DefaultContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { FileIcon, HashIcon } from 'lucide-vue-next'\nimport { computed } from 'vue'\nimport type { ContextItemProps } from './types'\nimport ContextItemWrapper from './ContextItemWrapper.vue'\n\nconst props = defineProps<ContextItemProps>()\n\nconst icon = computed(() => {\n  if (props.type === 'variable') return HashIcon\n  return FileIcon\n})\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"label\"\n    :type=\"type\"\n    :icon=\"icon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <!-- Default content just shows basic info -->\n    <div class=\"space-y-2 text-sm\">\n      <div class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\n        <span class=\"text-muted-foreground\">Label</span>\n        <span class=\"font-medium truncate\">{{ label }}</span>\n      </div>\n      <div v-if=\"metadata?.size\" class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\n        <span class=\"text-muted-foreground\">Size</span>\n        <span>{{ (metadata.size / 1024).toFixed(1) }} KB</span>\n      </div>\n      <div v-if=\"metadata?.mimeType\" class=\"grid grid-cols-[3rem_1fr] gap-2 items-center\">\n        <span class=\"text-muted-foreground\">Type</span>\n        <span class=\"font-mono text-xs\">{{ metadata.mimeType }}</span>\n      </div>\n    </div>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/registry/index.ts",
      "type": "registry:component",
      "content": "import { reactive } from 'vue'\nimport type { ContextItemRegistry, ContextItemComponent } from './types'\nimport DefaultContextItem from './DefaultContextItem.vue'\nimport NumberContextItem from './items/NumberContextItem.vue'\nimport SelectContextItem from './items/SelectContextItem.vue'\nimport DateContextItem from './items/DateContextItem.vue'\n\nexport function createContextItemRegistry(): ContextItemRegistry {\n  const components = reactive<Record<string, ContextItemComponent>>({\n    'default': DefaultContextItem,\n    'number': NumberContextItem,\n    'select': SelectContextItem,\n    'date': DateContextItem\n  })\n\n  const register = (type: string, component: ContextItemComponent) => {\n    components[type] = component\n  }\n\n  const get = (type: string) => {\n    return components[type] || components['default']\n  }\n\n  return {\n    register,\n    get\n  }\n}\n"
    },
    {
      "path": "ui/ai-input/registry/items/DateContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { CalendarIcon } from 'lucide-vue-next'\nimport { computed } from 'vue'\nimport type { ContextItemProps } from '../types'\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\nimport { Calendar } from '@/components/ui/calendar'\nimport { format } from 'date-fns'\n\nconst props = defineProps<ContextItemProps>()\n\n// Metadata structure: { date: string (ISO) }\nconst currentDate = computed(() => {\n  return props.metadata?.date ? new Date(props.metadata.date) : undefined\n})\n\nconst displayLabel = computed(() => {\n  const dateStr = currentDate.value ? format(currentDate.value, 'yyyy-MM-dd') : 'Pick a date'\n  return `${props.label}: ${dateStr}`\n})\n\nconst handleSelect = (date: Date | undefined) => {\n  if (!date) return\n  props.updateAttributes({\n    metadata: {\n      ...props.metadata,\n      date: date.toISOString()\n    }\n  })\n}\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"displayLabel\"\n    :type=\"type\"\n    :icon=\"CalendarIcon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <div class=\"p-2\">\n      <Calendar\n        mode=\"single\"\n        :model-value=\"currentDate\"\n        @update:model-value=\"handleSelect\"\n        class=\"rounded-md border\"\n      />\n    </div>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/registry/items/NumberContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { RulerIcon } from 'lucide-vue-next'\nimport { computed, ref, watch } from 'vue'\nimport type { ContextItemProps } from '../types'\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\nimport { Input } from '@/components/ui/input'\nimport { Label } from '@/components/ui/label'\nimport { Slider } from '@/components/ui/slider'\n\nconst props = defineProps<ContextItemProps>()\n\n// Metadata structure: { value: number, unit: string, min?: number, max?: number, step?: number }\nconst unit = computed(() => props.metadata?.unit || '')\nconst min = computed(() => props.metadata?.min ?? 0)\nconst max = computed(() => props.metadata?.max ?? 100)\nconst step = computed(() => props.metadata?.step ?? 1)\n\n// Local state for editing\nconst currentValue = ref(props.metadata?.value ?? 0)\n\n// Sync from props\nwatch(() => props.metadata?.value, (val) => {\n  if (val !== undefined) currentValue.value = val\n}, { immediate: true })\n\n// Sync to props\nconst updateValue = (val: number) => {\n  currentValue.value = val\n  props.updateAttributes({\n    metadata: {\n      ...props.metadata,\n      value: val\n    }\n  })\n}\n\nconst displayLabel = computed(() => {\n  return `${props.label}: ${currentValue.value}${unit.value ? ' ' + unit.value : ''}`\n})\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"displayLabel\"\n    :type=\"type\"\n    :icon=\"RulerIcon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <div class=\"space-y-4 py-2\">\n      <div class=\"space-y-1\">\n        <Label class=\"text-xs\">{{ label }} ({{ unit }})</Label>\n        <div class=\"flex items-center gap-2\">\n          <Input \n            type=\"number\" \n            :model-value=\"currentValue\"\n            @update:model-value=\"(v) => updateValue(Number(v))\"\n            :min=\"min\"\n            :max=\"max\"\n            :step=\"step\"\n            class=\"h-8\"\n          />\n        </div>\n      </div>\n      \n      <Slider\n        :model-value=\"[currentValue]\"\n        :min=\"min\"\n        :max=\"max\"\n        :step=\"step\"\n        @update:model-value=\"(v) => updateValue(v[0])\"\n      />\n    </div>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/registry/items/SelectContextItem.vue",
      "type": "registry:component",
      "content": "<script setup lang=\"ts\">\nimport { ListIcon, CheckIcon } from 'lucide-vue-next'\nimport { computed } from 'vue'\nimport type { ContextItemProps } from '../types'\nimport ContextItemWrapper from '../ContextItemWrapper.vue'\nimport { Command, CommandInput, CommandList, CommandItem, CommandEmpty, CommandGroup } from '@/components/ui/command'\nimport { cn } from '@/lib/utils'\n\nconst props = defineProps<ContextItemProps>()\n\n// Metadata structure: { value: string, options: { label: string, value: string }[] }\nconst options = computed(() => props.metadata?.options || [])\nconst currentValue = computed(() => props.metadata?.value)\n\nconst selectedOption = computed(() => \n  options.value.find((opt: any) => opt.value === currentValue.value)\n)\n\nconst displayLabel = computed(() => {\n  return `${props.label}: ${selectedOption.value?.label || currentValue.value || 'Select...'}`\n})\n\nconst handleSelect = (val: string) => {\n  props.updateAttributes({\n    metadata: {\n      ...props.metadata,\n      value: val\n    }\n  })\n}\n</script>\n\n<template>\n  <ContextItemWrapper\n    :id=\"id\"\n    :label=\"displayLabel\"\n    :type=\"type\"\n    :icon=\"ListIcon\"\n    :metadata=\"metadata\"\n    :selected=\"selected\"\n    :on-remove=\"deleteNode\"\n  >\n    <Command class=\"w-full\">\n      <CommandInput placeholder=\"Search options...\" class=\"h-8\" />\n      <CommandList>\n        <CommandEmpty>No option found.</CommandEmpty>\n        <CommandGroup>\n          <CommandItem\n            v-for=\"option in options\"\n            :key=\"option.value\"\n            :value=\"option.value\"\n            @select=\"handleSelect(option.value)\"\n          >\n            <CheckIcon\n              :class=\"cn(\n                'mr-2 h-4 w-4',\n                currentValue === option.value ? 'opacity-100' : 'opacity-0'\n              )\"\n            />\n            {{ option.label }}\n          </CommandItem>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  </ContextItemWrapper>\n</template>\n"
    },
    {
      "path": "ui/ai-input/registry/types.ts",
      "type": "registry:component",
      "content": "import type { Component } from 'vue'\n\nexport interface ContextItemProps {\n  // Tiptap node attributes\n  id: string\n  label: string\n  type: string\n  metadata?: Record<string, any>\n  \n  // Interaction state\n  selected: boolean\n  \n  // Actions\n  deleteNode: () => void\n  updateAttributes: (attrs: Record<string, any>) => void\n}\n\nexport type ContextItemComponent = Component<ContextItemProps>\n\nexport interface ContextItemRegistry {\n  register: (type: string, component: ContextItemComponent) => void\n  get: (type: string) => ContextItemComponent | undefined\n}\n\nexport const CONTEXT_ITEM_REGISTRY_KEY = Symbol('ContextItemRegistry')\n"
    },
    {
      "path": "ui/ai-input/types.ts",
      "type": "registry:component",
      "content": "import type { Editor } from '@tiptap/vue-3'\nimport type { Ref } from 'vue'\n\nexport interface UploadResult {\n  id: string\n  url?: string\n  name: string\n  type: string\n  // Extendable for other metadata\n}\n\nexport type UploadHandler = (\n  file: File, \n  onProgress?: (progress: number) => void\n) => Promise<UploadResult>\n\nexport interface AttachmentFile {\n  id: string\n  file?: File\n  type?: string\n  name?: string\n  \n  // Upload status\n  status: 'pending' | 'uploading' | 'done' | 'error'\n  progress: number\n  error?: Error\n  \n  // Server data after upload\n  serverData?: UploadResult\n}\n\nexport interface AIInputContext {\n  editor: Ref<Editor | undefined>\n  files: Ref<AttachmentFile[]>\n  isLoading: Ref<boolean>\n  isDisabled: Ref<boolean>\n  fileInputRef: Ref<HTMLInputElement | null>\n  \n  // Actions\n  setEditor: (instance: Editor) => void\n  addFiles: (files: File[] | FileList) => Promise<void>\n  removeFile: (id: string) => void\n  submit: () => void\n  focus: () => void\n  retryUpload: (id: string) => void\n  \n  // Helpers\n  isEmpty: Ref<boolean>\n  history: Ref<string[]>\n  isUploading: Ref<boolean>\n}\n\nexport const AI_INPUT_KEY = Symbol('AIInputContext')\n"
    },
    {
      "path": "ui/ai-input/useVoice.ts",
      "type": "registry:component",
      "content": "import { ref, onMounted, onUnmounted } from 'vue'\n\nexport type VoiceState = 'idle' | 'listening' | 'processing'\n\nexport function useVoice(onResult: (text: string) => void) {\n  const state = ref<VoiceState>('idle')\n  const recognition = ref<any>(null)\n  const isSupported = ref(false)\n\n  onMounted(() => {\n    const Win = window as any\n    const SpeechRecognition = Win.SpeechRecognition || Win.webkitSpeechRecognition\n\n    if (SpeechRecognition) {\n      isSupported.value = true\n      const sr = new SpeechRecognition()\n      sr.continuous = true\n      sr.interimResults = true\n      sr.lang = 'en-US'\n\n      sr.onstart = () => {\n        state.value = 'listening'\n      }\n\n      sr.onend = () => {\n        state.value = 'idle'\n      }\n\n      sr.onresult = (event: any) => {\n        let finalTranscript = ''\n        for (let i = event.resultIndex; i < event.results.length; i++) {\n          const result = event.results[i]\n          if (result.isFinal) {\n            finalTranscript += result[0]?.transcript ?? ''\n          }\n        }\n\n        if (finalTranscript) {\n          onResult(finalTranscript)\n        }\n      }\n\n      sr.onerror = (event: any) => {\n        console.error('Speech recognition error:', event.error)\n        state.value = 'idle'\n      }\n\n      recognition.value = sr\n    }\n  })\n\n  onUnmounted(() => {\n    recognition.value?.stop()\n  })\n\n  const start = () => {\n    if (!isSupported.value) return\n    recognition.value?.start()\n  }\n\n  const stop = () => {\n    recognition.value?.stop()\n  }\n\n  const toggle = () => {\n    if (state.value === 'listening') {\n      stop()\n    } else {\n      start()\n    }\n  }\n\n  return {\n    state,\n    isSupported,\n    start,\n    stop,\n    toggle,\n  }\n}\n"
    }
  ]
}